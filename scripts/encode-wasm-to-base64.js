#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * Script to encode WASM file to base64 and inline it into the cardano-serialization-lib package
 * This specifically handles the ES6 import pattern used by wasm-pack for bundler targets
 */

class CardanoWasmInliner {
    constructor(pkgDir = 'rust/pkg') {
        this.pkgDir = pkgDir;
        this.wasmFile = 'cardano_serialization_lib_bg.wasm';
        this.mainJsFile = 'cardano_serialization_lib.js';
        this.bgJsFile = 'cardano_serialization_lib_bg.js';
    }

    async processPackage() {
        console.log('üîß Processing Cardano Serialization Library WASM package...');
        
        // Check if files exist
        this.validateFiles();
        
        // Read and encode WASM
        const wasmData = this.readAndEncodeWasm();
        
        // Create inlined version
        this.createInlinedMainJs(wasmData);
        this.updatePackageJson();
        
        // Delete the original WASM file since it's now inlined
        this.deleteWasmFile();
        
        console.log('‚úÖ Successfully created inlined WASM package!');
        console.log(`üìä Original WASM size: ${(wasmData.buffer.length / 1024 / 1024).toFixed(2)} MB`);
        console.log(`üìä Base64 encoded size: ${(wasmData.base64.length / 1024 / 1024).toFixed(2)} MB`);
    }

    validateFiles() {
        const requiredFiles = [this.wasmFile, this.mainJsFile, this.bgJsFile, 'package.json'];
        
        for (const file of requiredFiles) {
            const filePath = path.join(this.pkgDir, file);
            if (!fs.existsSync(filePath)) {
                throw new Error(`Required file not found: ${filePath}`);
            }
        }
        
        console.log('‚úì All required files found');
    }

    readAndEncodeWasm() {
        const wasmPath = path.join(this.pkgDir, this.wasmFile);
        const wasmBuffer = fs.readFileSync(wasmPath);
        const wasmBase64 = wasmBuffer.toString('base64');
        
        console.log(`üìÅ Read WASM file: ${this.wasmFile}`);
        console.log(`üìä Size: ${wasmBuffer.length} bytes (${(wasmBuffer.length / 1024 / 1024).toFixed(2)} MB)`);
        
        return { buffer: wasmBuffer, base64: wasmBase64 };
    }

    generateInlinedWasmModule(wasmBase64) {
        return `// Inlined WebAssembly binary for cardano-serialization-lib
// Generated by encode-wasm-to-base64.js
const __CARDANO_WASM_BASE64__ = '${wasmBase64}';

// Create inlined WASM module that mimics the original ES6 import
import * as bg_js_imports from "./cardano_serialization_lib_bg.js";
const __createInlinedWasmModule__ = () => {
    // Decode base64 to binary
    const wasmBinary = (() => {
        if (typeof Buffer !== 'undefined') {
            // Node.js environment
            return Buffer.from(__CARDANO_WASM_BASE64__, 'base64');
        } else {
            // Browser environment
            const binaryString = atob(__CARDANO_WASM_BASE64__);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes;
        }
    })();

    // Synchronously instantiate WASM module
    const wasmModule = new WebAssembly.Module(wasmBinary);
    const wasmInstance = new WebAssembly.Instance(wasmModule, {
        './cardano_serialization_lib_bg.js': bg_js_imports
    });
    
    // Create an object that mimics the ES6 import result
    const wasmExports = wasmInstance.exports;
    
    // Add the memory property that the background JS expects
    return {
        ...wasmExports,
        memory: wasmExports.memory
    };
};

// Initialize the wasm variable with our inlined version
const wasm = __createInlinedWasmModule__();`;
    }

    createInlinedMainJs(wasmData) {
        const mainJsPath = path.join(this.pkgDir, this.mainJsFile);
        const originalContent = fs.readFileSync(mainJsPath, 'utf8');
        
        // Create the inlined WASM module
        const inlinedWasmModule = this.generateInlinedWasmModule(wasmData.base64);
        
        // Replace the WASM import but keep __wbg_set_wasm import and call
        const newContent = originalContent.replace(
            /import \* as wasm from ["']\.\/cardano_serialization_lib_bg\.wasm[""];/g,
            '// WASM module inlined - see top of file'
        );
        
        // Add the inlined WASM module at the beginning of the file
        const finalContent = `${inlinedWasmModule}\n\n${newContent}`;
        
        fs.writeFileSync(mainJsPath, finalContent);
        console.log(`‚úèÔ∏è  Modified ${this.mainJsFile} with inlined WASM and proper bg.js integration`);
    }

    updatePackageJson() {
        const packageJsonPath = path.join(this.pkgDir, 'package.json');
        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
        
        // Remove WASM file from files array
        if (packageJson.files) {
            packageJson.files = packageJson.files.filter(file => 
                !file.endsWith('.wasm')
            );
        }
        
        // Update description
        if (packageJson.description && !packageJson.description.includes('inlined')) {
            packageJson.description += ' (WebAssembly inlined)';
        }
        
        fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
        console.log('‚úèÔ∏è  Updated package.json');
    }

    deleteWasmFile() {
        const wasmPath = path.join(this.pkgDir, this.wasmFile);
        if (fs.existsSync(wasmPath)) {
            fs.unlinkSync(wasmPath);
            console.log(`üóëÔ∏è  Deleted original WASM file: ${this.wasmFile}`);
        }
    }
}

// Utility functions for base64 encoding and analysis
class WasmAnalyzer {
    static analyzeWasmFile(filePath) {
        if (!fs.existsSync(filePath)) {
            throw new Error(`WASM file not found: ${filePath}`);
        }
        
        const wasmBuffer = fs.readFileSync(filePath);
        const wasmBase64 = wasmBuffer.toString('base64');
        
        console.log('üìä WASM File Analysis:');
        console.log(`   Binary size: ${wasmBuffer.length} bytes (${(wasmBuffer.length / 1024).toFixed(2)} KB)`);
        console.log(`   Base64 size: ${wasmBase64.length} chars (${(wasmBase64.length / 1024).toFixed(2)} KB)`);
        console.log(`   Size increase: ${((wasmBase64.length / wasmBuffer.length) * 100).toFixed(1)}%`);
        
        // Check WASM magic number
        const magicNumber = wasmBuffer.slice(0, 4);
        const expectedMagic = Buffer.from([0x00, 0x61, 0x73, 0x6D]); // "\0asm"
        const isValidWasm = magicNumber.equals(expectedMagic);
        
        console.log(`   Valid WASM: ${isValidWasm ? '‚úÖ' : '‚ùå'}`);
        
        if (isValidWasm) {
            const version = wasmBuffer.readUInt32LE(4);
            console.log(`   WASM version: ${version}`);
        }
        
        return { buffer: wasmBuffer, base64: wasmBase64, isValid: isValidWasm };
    }
    
    static saveBase64ToFile(base64Data, outputPath) {
        fs.writeFileSync(outputPath, base64Data);
        console.log(`üíæ Saved base64 data to: ${outputPath}`);
    }
}

// CLI interface
function main() {
    const args = process.argv.slice(2);
    
    if (args.includes('--help') || args.includes('-h')) {
        console.log(`
Usage: node encode-wasm-to-base64.js [command] [options]

Commands:
  analyze [file]    Analyze a WASM file and show base64 encoding info
  inline [dir]      Inline WASM into the cardano-serialization-lib package
  encode [file]     Encode a WASM file to base64 and save to file

Options:
  --help, -h        Show this help message
  --output, -o      Specify output file for encode command

Examples:
  node encode-wasm-to-base64.js analyze rust/pkg/cardano_serialization_lib_bg.wasm
  node encode-wasm-to-base64.js inline rust/pkg
  node encode-wasm-to-base64.js encode myfile.wasm --output myfile.base64
        `);
        return;
    }
    
    const command = args[0] || 'inline';
    
    try {
        switch (command) {
            case 'analyze': {
                const filePath = args[1] || 'rust/pkg/cardano_serialization_lib_bg.wasm';
                WasmAnalyzer.analyzeWasmFile(filePath);
                break;
            }
            
            case 'inline': {
                const pkgDir = args[1] || 'rust/pkg';
                const inliner = new CardanoWasmInliner(pkgDir);
                inliner.processPackage();
                break;
            }
            
            case 'encode': {
                const filePath = args[1];
                if (!filePath) {
                    console.error('‚ùå Please specify a WASM file to encode');
                    process.exit(1);
                }
                
                const outputIndex = args.findIndex(arg => arg === '--output' || arg === '-o');
                const outputPath = outputIndex !== -1 && args[outputIndex + 1] 
                    ? args[outputIndex + 1] 
                    : filePath + '.base64';
                
                const { base64 } = WasmAnalyzer.analyzeWasmFile(filePath);
                WasmAnalyzer.saveBase64ToFile(base64, outputPath);
                break;
            }
            
            default:
                console.error(`‚ùå Unknown command: ${command}`);
                console.log('Use --help for usage information');
                process.exit(1);
        }
    } catch (error) {
        console.error(`‚ùå Error: ${error.message}`);
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}

module.exports = { CardanoWasmInliner, WasmAnalyzer };