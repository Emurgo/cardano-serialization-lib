/**
 * Flowtype definitions for cddl_lib
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.11.0
 * @flow
 */

/**
 * @param {Transaction} tx
 * @returns {number}
 */
declare export function min_fee(tx: Transaction): number;
declare export class AddrKeyHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {AddrKeyHash}
   */
  static from_bytes(bytes: Uint8Array): AddrKeyHash;
}
declare export class AddrKeyHashes {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {AddrKeyHashes}
   */
  static from_bytes(bytes: Uint8Array): AddrKeyHashes;

  /**
   * @returns {AddrKeyHashes}
   */
  static new(): AddrKeyHashes;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {AddrKeyHash}
   */
  get(index: number): AddrKeyHash;

  /**
   * @param {AddrKeyHash} elem
   */
  add(elem: AddrKeyHash): void;
}
declare export class Address {
  free(): void;

  /**
   * @param {Uint8Array} data
   * @returns {Address}
   */
  static from_bytes(data: Uint8Array): Address;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @returns {string}
   */
  to_bech32(): string;

  /**
   * @param {string} bech_str
   * @returns {Address}
   */
  static from_bech32(bech_str: string): Address;

  /**
   * @returns {number}
   */
  network_id(): number;
}
declare export class BaseAddress {
  free(): void;

  /**
   * @param {number} network
   * @param {StakeCredential} payment
   * @param {StakeCredential} stake
   * @returns {BaseAddress}
   */
  static new(
    network: number,
    payment: StakeCredential,
    stake: StakeCredential
  ): BaseAddress;

  /**
   * @returns {StakeCredential}
   */
  payment_cred(): StakeCredential;

  /**
   * @returns {StakeCredential}
   */
  stake_cred(): StakeCredential;

  /**
   * @returns {Address}
   */
  to_address(): Address;
}
declare export class Bip32PrivateKey {
  free(): void;

  /**
   * derive this private key with the given index.
   *
   * # Security considerations
   *
   * * hard derivation index cannot be soft derived with the public key
   *
   * # Hard derivation vs Soft derivation
   *
   * If you pass an index below 0x80000000 then it is a soft derivation.
   * The advantage of soft derivation is that it is possible to derive the
   * public key too. I.e. derivation the private key with a soft derivation
   * index and then retrieving the associated public key is equivalent to
   * deriving the public key associated to the parent private key.
   *
   * Hard derivation index does not allow public key derivation.
   *
   * This is why deriving the private key should not fail while deriving
   * the public key may fail (if the derivation index is invalid).
   * @param {number} index
   * @returns {Bip32PrivateKey}
   */
  derive(index: number): Bip32PrivateKey;

  /**
   * @returns {Bip32PrivateKey}
   */
  static generate_ed25519_bip32(): Bip32PrivateKey;

  /**
   * @returns {PrivateKey}
   */
  to_raw_key(): PrivateKey;

  /**
   * @returns {Bip32PublicKey}
   */
  to_public(): Bip32PublicKey;

  /**
   * @param {Uint8Array} bytes
   * @returns {Bip32PrivateKey}
   */
  static from_bytes(bytes: Uint8Array): Bip32PrivateKey;

  /**
   * @returns {Uint8Array}
   */
  as_bytes(): Uint8Array;

  /**
   * @param {string} bech32_str
   * @returns {Bip32PrivateKey}
   */
  static from_bech32(bech32_str: string): Bip32PrivateKey;

  /**
   * @returns {string}
   */
  to_bech32(): string;

  /**
   * @param {Uint8Array} entropy
   * @param {Uint8Array} password
   * @returns {Bip32PrivateKey}
   */
  static from_bip39_entropy(
    entropy: Uint8Array,
    password: Uint8Array
  ): Bip32PrivateKey;
}
declare export class Bip32PublicKey {
  free(): void;

  /**
   * derive this public key with the given index.
   *
   * # Errors
   *
   * If the index is not a soft derivation index (< 0x80000000) then
   * calling this method will fail.
   *
   * # Security considerations
   *
   * * hard derivation index cannot be soft derived with the public key
   *
   * # Hard derivation vs Soft derivation
   *
   * If you pass an index below 0x80000000 then it is a soft derivation.
   * The advantage of soft derivation is that it is possible to derive the
   * public key too. I.e. derivation the private key with a soft derivation
   * index and then retrieving the associated public key is equivalent to
   * deriving the public key associated to the parent private key.
   *
   * Hard derivation index does not allow public key derivation.
   *
   * This is why deriving the private key should not fail while deriving
   * the public key may fail (if the derivation index is invalid).
   * @param {number} index
   * @returns {Bip32PublicKey}
   */
  derive(index: number): Bip32PublicKey;

  /**
   * @returns {PublicKey}
   */
  to_raw_key(): PublicKey;

  /**
   * @param {Uint8Array} bytes
   * @returns {Bip32PublicKey}
   */
  static from_bytes(bytes: Uint8Array): Bip32PublicKey;

  /**
   * @returns {Uint8Array}
   */
  as_bytes(): Uint8Array;

  /**
   * @param {string} bech32_str
   * @returns {Bip32PublicKey}
   */
  static from_bech32(bech32_str: string): Bip32PublicKey;

  /**
   * @returns {string}
   */
  to_bech32(): string;

  /**
   * @returns {AddrKeyHash}
   */
  hash(): AddrKeyHash;
}
declare export class BootstrapWitness {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {BootstrapWitness}
   */
  static from_bytes(bytes: Uint8Array): BootstrapWitness;

  /**
   * @param {Vkey} vkey
   * @param {Ed25519Signature} signature
   * @param {Uint8Array} index_2
   * @param {Uint8Array} index_3
   * @param {Uint8Array} index_4
   * @returns {BootstrapWitness}
   */
  static new(
    vkey: Vkey,
    signature: Ed25519Signature,
    index_2: Uint8Array,
    index_3: Uint8Array,
    index_4: Uint8Array
  ): BootstrapWitness;
}
declare export class BootstrapWitnesses {
  free(): void;

  /**
   * @returns {BootstrapWitnesses}
   */
  static new(): BootstrapWitnesses;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {BootstrapWitness}
   */
  get(index: number): BootstrapWitness;

  /**
   * @param {BootstrapWitness} elem
   */
  add(elem: BootstrapWitness): void;
}
declare export class Certificate {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Certificate}
   */
  static from_bytes(bytes: Uint8Array): Certificate;

  /**
   * @param {StakeRegistration} stake_registration
   * @returns {Certificate}
   */
  static new_stake_registration(
    stake_registration: StakeRegistration
  ): Certificate;

  /**
   * @param {StakeDeregistration} stake_deregistration
   * @returns {Certificate}
   */
  static new_stake_deregistration(
    stake_deregistration: StakeDeregistration
  ): Certificate;

  /**
   * @param {StakeDelegation} stake_delegation
   * @returns {Certificate}
   */
  static new_stake_delegation(stake_delegation: StakeDelegation): Certificate;

  /**
   * @param {PoolRegistration} pool_registration
   * @returns {Certificate}
   */
  static new_pool_registration(
    pool_registration: PoolRegistration
  ): Certificate;

  /**
   * @param {PoolRetirement} pool_retirement
   * @returns {Certificate}
   */
  static new_pool_retirement(pool_retirement: PoolRetirement): Certificate;

  /**
   * @param {GenesisKeyDelegation} genesis_key_delegation
   * @returns {Certificate}
   */
  static new_genesis_key_delegation(
    genesis_key_delegation: GenesisKeyDelegation
  ): Certificate;

  /**
   * @param {MoveInstantaneousRewardsCert} move_instantaneous_rewards_cert
   * @returns {Certificate}
   */
  static new_move_instantaneous_rewards_cert(
    move_instantaneous_rewards_cert: MoveInstantaneousRewardsCert
  ): Certificate;
}
declare export class Certificates {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Certificates}
   */
  static from_bytes(bytes: Uint8Array): Certificates;

  /**
   * @returns {Certificates}
   */
  static new(): Certificates;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {Certificate}
   */
  get(index: number): Certificate;

  /**
   * @param {Certificate} elem
   */
  add(elem: Certificate): void;
}
declare export class Ed25519Signature {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @returns {string}
   */
  to_bech32(): string;

  /**
   * @returns {string}
   */
  to_hex(): string;

  /**
   * @param {string} bech32_str
   * @returns {Ed25519Signature}
   */
  static from_bech32(bech32_str: string): Ed25519Signature;

  /**
   * @param {string} input
   * @returns {Ed25519Signature}
   */
  static from_hex(input: string): Ed25519Signature;

  /**
   * @param {Uint8Array} bytes
   * @returns {Ed25519Signature}
   */
  static from_bytes(bytes: Uint8Array): Ed25519Signature;
}
declare export class EnterpriseAddress {
  free(): void;

  /**
   * @param {number} network
   * @param {StakeCredential} payment
   * @returns {EnterpriseAddress}
   */
  static new(network: number, payment: StakeCredential): EnterpriseAddress;

  /**
   * @returns {StakeCredential}
   */
  payment_cred(): StakeCredential;

  /**
   * @returns {Address}
   */
  to_address(): Address;
}
declare export class GenesisDelegateHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {GenesisDelegateHash}
   */
  static from_bytes(bytes: Uint8Array): GenesisDelegateHash;
}
declare export class GenesisHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {GenesisHash}
   */
  static from_bytes(bytes: Uint8Array): GenesisHash;
}
declare export class GenesisKeyDelegation {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {GenesisKeyDelegation}
   */
  static from_bytes(bytes: Uint8Array): GenesisKeyDelegation;

  /**
   * @param {GenesisHash} genesishash
   * @param {GenesisDelegateHash} genesis_delegate_hash
   * @returns {GenesisKeyDelegation}
   */
  static new(
    genesishash: GenesisHash,
    genesis_delegate_hash: GenesisDelegateHash
  ): GenesisKeyDelegation;
}
declare export class I0OrI1 {
  free(): void;

  /**
   * @returns {I0OrI1}
   */
  static new_i0(): I0OrI1;

  /**
   * @returns {I0OrI1}
   */
  static new_i1(): I0OrI1;
}
declare export class Int {
  free(): void;

  /**
   * @param {BigInt} x
   * @returns {Int}
   */
  static new(x: BigInt): Int;

  /**
   * @param {BigInt} x
   * @returns {Int}
   */
  static new_negative(x: BigInt): Int;
}
declare export class Ipv4 {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Ipv4}
   */
  static from_bytes(bytes: Uint8Array): Ipv4;

  /**
   * @param {Uint8Array} data
   * @returns {Ipv4}
   */
  static new(data: Uint8Array): Ipv4;
}
declare export class Ipv6 {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Ipv6}
   */
  static from_bytes(bytes: Uint8Array): Ipv6;

  /**
   * @param {Uint8Array} data
   * @returns {Ipv6}
   */
  static new(data: Uint8Array): Ipv6;
}
declare export class MapStakeCredentialToCoin {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MapStakeCredentialToCoin}
   */
  static from_bytes(bytes: Uint8Array): MapStakeCredentialToCoin;

  /**
   * @returns {MapStakeCredentialToCoin}
   */
  static new(): MapStakeCredentialToCoin;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {StakeCredential} key
   * @param {BigInt} value
   * @returns {BigInt | void}
   */
  insert(key: StakeCredential, value: BigInt): BigInt | void;
}
declare export class MapTransactionMetadatumToTransactionMetadatum {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MapTransactionMetadatumToTransactionMetadatum}
   */
  static from_bytes(
    bytes: Uint8Array
  ): MapTransactionMetadatumToTransactionMetadatum;

  /**
   * @returns {MapTransactionMetadatumToTransactionMetadatum}
   */
  static new(): MapTransactionMetadatumToTransactionMetadatum;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {TransactionMetadatum} key
   * @param {TransactionMetadatum} value
   * @returns {TransactionMetadatum | void}
   */
  insert(
    key: TransactionMetadatum,
    value: TransactionMetadatum
  ): TransactionMetadatum | void;
}
declare export class MetadataHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MetadataHash}
   */
  static from_bytes(bytes: Uint8Array): MetadataHash;
}
declare export class MoveInstantaneousReward {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MoveInstantaneousReward}
   */
  static from_bytes(bytes: Uint8Array): MoveInstantaneousReward;

  /**
   * @param {I0OrI1} index_0
   * @param {MapStakeCredentialToCoin} index_1
   * @returns {MoveInstantaneousReward}
   */
  static new(
    index_0: I0OrI1,
    index_1: MapStakeCredentialToCoin
  ): MoveInstantaneousReward;
}
declare export class MoveInstantaneousRewardsCert {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MoveInstantaneousRewardsCert}
   */
  static from_bytes(bytes: Uint8Array): MoveInstantaneousRewardsCert;

  /**
   * @param {MoveInstantaneousReward} move_instantaneous_reward
   * @returns {MoveInstantaneousRewardsCert}
   */
  static new(
    move_instantaneous_reward: MoveInstantaneousReward
  ): MoveInstantaneousRewardsCert;
}
declare export class MsigAll {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MsigAll}
   */
  static from_bytes(bytes: Uint8Array): MsigAll;

  /**
   * @param {MultisigScripts} multisig_scripts
   * @returns {MsigAll}
   */
  static new(multisig_scripts: MultisigScripts): MsigAll;
}
declare export class MsigAny {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MsigAny}
   */
  static from_bytes(bytes: Uint8Array): MsigAny;

  /**
   * @param {MultisigScripts} multisig_scripts
   * @returns {MsigAny}
   */
  static new(multisig_scripts: MultisigScripts): MsigAny;
}
declare export class MsigNOfK {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MsigNOfK}
   */
  static from_bytes(bytes: Uint8Array): MsigNOfK;

  /**
   * @param {number} n
   * @param {MultisigScripts} multisig_scripts
   * @returns {MsigNOfK}
   */
  static new(n: number, multisig_scripts: MultisigScripts): MsigNOfK;
}
declare export class MsigPubkey {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MsigPubkey}
   */
  static from_bytes(bytes: Uint8Array): MsigPubkey;

  /**
   * @param {AddrKeyHash} addr_keyhash
   * @returns {MsigPubkey}
   */
  static new(addr_keyhash: AddrKeyHash): MsigPubkey;
}
declare export class MultiHostName {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MultiHostName}
   */
  static from_bytes(bytes: Uint8Array): MultiHostName;

  /**
   * @param {string} dns_name
   * @returns {MultiHostName}
   */
  static new(dns_name: string): MultiHostName;
}
declare export class MultisigScript {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MultisigScript}
   */
  static from_bytes(bytes: Uint8Array): MultisigScript;

  /**
   * @param {AddrKeyHash} addr_keyhash
   * @returns {MultisigScript}
   */
  static new_msig_pubkey(addr_keyhash: AddrKeyHash): MultisigScript;

  /**
   * @param {MultisigScripts} multisig_scripts
   * @returns {MultisigScript}
   */
  static new_msig_all(multisig_scripts: MultisigScripts): MultisigScript;

  /**
   * @param {MultisigScripts} multisig_scripts
   * @returns {MultisigScript}
   */
  static new_msig_any(multisig_scripts: MultisigScripts): MultisigScript;

  /**
   * @param {number} n
   * @param {MultisigScripts} multisig_scripts
   * @returns {MultisigScript}
   */
  static new_msig_n_of_k(
    n: number,
    multisig_scripts: MultisigScripts
  ): MultisigScript;
}
declare export class MultisigScripts {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MultisigScripts}
   */
  static from_bytes(bytes: Uint8Array): MultisigScripts;

  /**
   * @returns {MultisigScripts}
   */
  static new(): MultisigScripts;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {MultisigScript}
   */
  get(index: number): MultisigScript;

  /**
   * @param {MultisigScript} elem
   */
  add(elem: MultisigScript): void;
}
declare export class Pointer {
  free(): void;

  /**
   * @param {BigInt} slot
   * @param {BigInt} tx_index
   * @param {BigInt} cert_index
   * @returns {Pointer}
   */
  static new(slot: BigInt, tx_index: BigInt, cert_index: BigInt): Pointer;
}
declare export class PointerAddress {
  free(): void;

  /**
   * @param {number} network
   * @param {StakeCredential} payment
   * @param {Pointer} stake
   * @returns {PointerAddress}
   */
  static new(
    network: number,
    payment: StakeCredential,
    stake: Pointer
  ): PointerAddress;

  /**
   * @returns {StakeCredential}
   */
  payment_cred(): StakeCredential;

  /**
   * @returns {Pointer}
   */
  stake_ponter(): Pointer;

  /**
   * @returns {Address}
   */
  to_address(): Address;
}
declare export class PoolKeyHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {PoolKeyHash}
   */
  static from_bytes(bytes: Uint8Array): PoolKeyHash;
}
declare export class PoolMetadata {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {PoolMetadata}
   */
  static from_bytes(bytes: Uint8Array): PoolMetadata;

  /**
   * @param {string} url
   * @param {MetadataHash} metadata_hash
   * @returns {PoolMetadata}
   */
  static new(url: string, metadata_hash: MetadataHash): PoolMetadata;
}
declare export class PoolParams {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {PoolParams}
   */
  static from_bytes(bytes: Uint8Array): PoolParams;

  /**
   * @param {PoolKeyHash} operator
   * @param {VRFKeyHash} vrf_keyhash
   * @param {BigInt} pledge
   * @param {BigInt} cost
   * @param {UnitInterval} margin
   * @param {RewardAddress} reward_account
   * @param {AddrKeyHashes} pool_owners
   * @param {Relays} relays
   * @param {PoolMetadata | void} pool_metadata
   * @returns {PoolParams}
   */
  static new(
    operator: PoolKeyHash,
    vrf_keyhash: VRFKeyHash,
    pledge: BigInt,
    cost: BigInt,
    margin: UnitInterval,
    reward_account: RewardAddress,
    pool_owners: AddrKeyHashes,
    relays: Relays,
    pool_metadata?: PoolMetadata
  ): PoolParams;
}
declare export class PoolRegistration {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {PoolRegistration}
   */
  static from_bytes(bytes: Uint8Array): PoolRegistration;

  /**
   * @param {PoolParams} pool_params
   * @returns {PoolRegistration}
   */
  static new(pool_params: PoolParams): PoolRegistration;
}
declare export class PoolRetirement {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {PoolRetirement}
   */
  static from_bytes(bytes: Uint8Array): PoolRetirement;

  /**
   * @param {PoolKeyHash} pool_keyhash
   * @param {number} epoch
   * @returns {PoolRetirement}
   */
  static new(pool_keyhash: PoolKeyHash, epoch: number): PoolRetirement;
}
declare export class PrivateKey {
  free(): void;

  /**
   * @returns {PublicKey}
   */
  to_public(): PublicKey;

  /**
   * @returns {PrivateKey}
   */
  static generate_ed25519(): PrivateKey;

  /**
   * @returns {PrivateKey}
   */
  static generate_ed25519extended(): PrivateKey;

  /**
   * @returns {string}
   */
  to_bech32(): string;

  /**
   * @returns {Uint8Array}
   */
  as_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {PrivateKey}
   */
  static from_extended_bytes(bytes: Uint8Array): PrivateKey;

  /**
   * @param {Uint8Array} bytes
   * @returns {PrivateKey}
   */
  static from_normal_bytes(bytes: Uint8Array): PrivateKey;

  /**
   * @param {Uint8Array} message
   * @returns {Ed25519Signature}
   */
  sign(message: Uint8Array): Ed25519Signature;
}
declare export class PublicKey {
  free(): void;

  /**
   * Get private key from its bech32 representation
   * Example:
   * ```javascript
   * const pkey = PublicKey.from_bech32(&#39;ed25519_pk1dgaagyh470y66p899txcl3r0jaeaxu6yd7z2dxyk55qcycdml8gszkxze2&#39;);
   * ```
   * @param {string} bech32_str
   * @returns {PublicKey}
   */
  static from_bech32(bech32_str: string): PublicKey;

  /**
   * @returns {string}
   */
  to_bech32(): string;

  /**
   * @returns {Uint8Array}
   */
  as_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {PublicKey}
   */
  static from_bytes(bytes: Uint8Array): PublicKey;

  /**
   * @param {Uint8Array} data
   * @param {Ed25519Signature} signature
   * @returns {boolean}
   */
  verify(data: Uint8Array, signature: Ed25519Signature): boolean;

  /**
   * @returns {AddrKeyHash}
   */
  hash(): AddrKeyHash;
}
declare export class PublicKeys {
  free(): void;

  /**
   */
  constructor(): this;

  /**
   * @returns {number}
   */
  size(): number;

  /**
   * @param {number} index
   * @returns {PublicKey}
   */
  get(index: number): PublicKey;

  /**
   * @param {PublicKey} key
   */
  add(key: PublicKey): void;
}
declare export class Relay {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Relay}
   */
  static from_bytes(bytes: Uint8Array): Relay;

  /**
   * @param {SingleHostAddr} single_host_addr
   * @returns {Relay}
   */
  static new_single_host_addr(single_host_addr: SingleHostAddr): Relay;

  /**
   * @param {SingleHostName} single_host_name
   * @returns {Relay}
   */
  static new_single_host_name(single_host_name: SingleHostName): Relay;

  /**
   * @param {MultiHostName} multi_host_name
   * @returns {Relay}
   */
  static new_multi_host_name(multi_host_name: MultiHostName): Relay;
}
declare export class Relays {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Relays}
   */
  static from_bytes(bytes: Uint8Array): Relays;

  /**
   * @returns {Relays}
   */
  static new(): Relays;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {Relay}
   */
  get(index: number): Relay;

  /**
   * @param {Relay} elem
   */
  add(elem: Relay): void;
}
declare export class RewardAddress {
  free(): void;

  /**
   * @param {number} network
   * @param {StakeCredential} payment
   * @returns {RewardAddress}
   */
  static new(network: number, payment: StakeCredential): RewardAddress;

  /**
   * @returns {StakeCredential}
   */
  payment_cred(): StakeCredential;

  /**
   * @returns {Address}
   */
  to_address(): Address;
}
declare export class ScriptHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptHash}
   */
  static from_bytes(bytes: Uint8Array): ScriptHash;
}
declare export class SingleHostAddr {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {SingleHostAddr}
   */
  static from_bytes(bytes: Uint8Array): SingleHostAddr;

  /**
   * @param {number | void} port
   * @param {Ipv4 | void} ipv4
   * @param {Ipv6 | void} ipv6
   * @returns {SingleHostAddr}
   */
  static new(port?: number, ipv4?: Ipv4, ipv6?: Ipv6): SingleHostAddr;
}
declare export class SingleHostName {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {SingleHostName}
   */
  static from_bytes(bytes: Uint8Array): SingleHostName;

  /**
   * @param {number | void} port
   * @param {string} dns_name
   * @returns {SingleHostName}
   */
  static new(port: number | void, dns_name: string): SingleHostName;
}
declare export class StakeCredential {
  free(): void;

  /**
   * @param {AddrKeyHash} hash
   * @returns {StakeCredential}
   */
  static from_keyhash(hash: AddrKeyHash): StakeCredential;

  /**
   * @param {ScriptHash} hash
   * @returns {StakeCredential}
   */
  static from_scripthash(hash: ScriptHash): StakeCredential;

  /**
   * @returns {AddrKeyHash | void}
   */
  to_keyhash(): AddrKeyHash | void;

  /**
   * @returns {ScriptHash | void}
   */
  to_scripthash(): ScriptHash | void;

  /**
   * @returns {number}
   */
  kind(): number;
}
declare export class StakeDelegation {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {StakeDelegation}
   */
  static from_bytes(bytes: Uint8Array): StakeDelegation;

  /**
   * @param {StakeCredential} stake_credential
   * @param {PoolKeyHash} pool_keyhash
   * @returns {StakeDelegation}
   */
  static new(
    stake_credential: StakeCredential,
    pool_keyhash: PoolKeyHash
  ): StakeDelegation;
}
declare export class StakeDeregistration {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {StakeDeregistration}
   */
  static from_bytes(bytes: Uint8Array): StakeDeregistration;

  /**
   * @param {StakeCredential} stake_credential
   * @returns {StakeDeregistration}
   */
  static new(stake_credential: StakeCredential): StakeDeregistration;
}
declare export class StakeRegistration {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {StakeRegistration}
   */
  static from_bytes(bytes: Uint8Array): StakeRegistration;

  /**
   * @param {StakeCredential} stake_credential
   * @returns {StakeRegistration}
   */
  static new(stake_credential: StakeCredential): StakeRegistration;
}
declare export class Transaction {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Transaction}
   */
  static from_bytes(bytes: Uint8Array): Transaction;

  /**
   * @param {TransactionBody} body
   * @param {TransactionWitnessSet} witness_set
   * @param {TransactionMetadata | void} metadata
   * @returns {Transaction}
   */
  static new(
    body: TransactionBody,
    witness_set: TransactionWitnessSet,
    metadata?: TransactionMetadata
  ): Transaction;
}
declare export class TransactionBody {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionBody}
   */
  static from_bytes(bytes: Uint8Array): TransactionBody;

  /**
   * @param {Certificates} certs
   */
  set_certs(certs: Certificates): void;

  /**
   * @param {Withdrawals} withdrawals
   */
  set_withdrawals(withdrawals: Withdrawals): void;

  /**
   * @param {MetadataHash} metadata_hash
   */
  set_metadata_hash(metadata_hash: MetadataHash): void;

  /**
   * @param {TransactionInputs} inputs
   * @param {TransactionOutputs} outputs
   * @param {BigInt} fee
   * @param {number} ttl
   * @returns {TransactionBody}
   */
  static new(
    inputs: TransactionInputs,
    outputs: TransactionOutputs,
    fee: BigInt,
    ttl: number
  ): TransactionBody;

  /**
   * @returns {TransactionHash}
   */
  hash(): TransactionHash;

  /**
   * @param {PrivateKey} sk
   * @returns {Vkeywitness}
   */
  sign(sk: PrivateKey): Vkeywitness;
}
declare export class TransactionHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionHash}
   */
  static from_bytes(bytes: Uint8Array): TransactionHash;
}
declare export class TransactionInput {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionInput}
   */
  static from_bytes(bytes: Uint8Array): TransactionInput;

  /**
   * @param {TransactionHash} transaction_id
   * @param {number} index
   * @returns {TransactionInput}
   */
  static new(transaction_id: TransactionHash, index: number): TransactionInput;
}
declare export class TransactionInputs {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionInputs}
   */
  static from_bytes(bytes: Uint8Array): TransactionInputs;

  /**
   * @returns {TransactionInputs}
   */
  static new(): TransactionInputs;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {TransactionInput}
   */
  get(index: number): TransactionInput;

  /**
   * @param {TransactionInput} elem
   */
  add(elem: TransactionInput): void;
}
declare export class TransactionMetadata {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionMetadata}
   */
  static from_bytes(bytes: Uint8Array): TransactionMetadata;

  /**
   * @returns {TransactionMetadata}
   */
  static new(): TransactionMetadata;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {BigInt} key
   * @param {TransactionMetadatum} value
   * @returns {TransactionMetadatum | void}
   */
  insert(key: BigInt, value: TransactionMetadatum): TransactionMetadatum | void;
}
declare export class TransactionMetadatum {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionMetadatum}
   */
  static from_bytes(bytes: Uint8Array): TransactionMetadatum;

  /**
   * @param {MapTransactionMetadatumToTransactionMetadatum} map_transaction_metadatum_to_transaction_metadatum
   * @returns {TransactionMetadatum}
   */
  static new_map_transaction_metadatum_to_transaction_metadatum(
    map_transaction_metadatum_to_transaction_metadatum: MapTransactionMetadatumToTransactionMetadatum
  ): TransactionMetadatum;

  /**
   * @param {TransactionMetadatums} arr_transaction_metadatum
   * @returns {TransactionMetadatum}
   */
  static new_arr_transaction_metadatum(
    arr_transaction_metadatum: TransactionMetadatums
  ): TransactionMetadatum;

  /**
   * @param {Int} int
   * @returns {TransactionMetadatum}
   */
  static new_int(int: Int): TransactionMetadatum;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionMetadatum}
   */
  static new_bytes(bytes: Uint8Array): TransactionMetadatum;

  /**
   * @param {string} text
   * @returns {TransactionMetadatum}
   */
  static new_text(text: string): TransactionMetadatum;
}
declare export class TransactionMetadatums {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionMetadatums}
   */
  static from_bytes(bytes: Uint8Array): TransactionMetadatums;

  /**
   * @returns {TransactionMetadatums}
   */
  static new(): TransactionMetadatums;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {TransactionMetadatum}
   */
  get(index: number): TransactionMetadatum;

  /**
   * @param {TransactionMetadatum} elem
   */
  add(elem: TransactionMetadatum): void;
}
declare export class TransactionOutput {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionOutput}
   */
  static from_bytes(bytes: Uint8Array): TransactionOutput;

  /**
   * @param {Address} address
   * @param {BigInt} amount
   * @returns {TransactionOutput}
   */
  static new(address: Address, amount: BigInt): TransactionOutput;
}
declare export class TransactionOutputs {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionOutputs}
   */
  static from_bytes(bytes: Uint8Array): TransactionOutputs;

  /**
   * @returns {TransactionOutputs}
   */
  static new(): TransactionOutputs;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {TransactionOutput}
   */
  get(index: number): TransactionOutput;

  /**
   * @param {TransactionOutput} elem
   */
  add(elem: TransactionOutput): void;
}
declare export class TransactionWitnessSet {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionWitnessSet}
   */
  static from_bytes(bytes: Uint8Array): TransactionWitnessSet;

  /**
   * @param {Vkeywitnesses} vkeys
   */
  set_vkeys(vkeys: Vkeywitnesses): void;

  /**
   * @param {MultisigScripts} scripts
   */
  set_scripts(scripts: MultisigScripts): void;

  /**
   * @param {BootstrapWitnesses} bootstraps
   */
  set_bootstraps(bootstraps: BootstrapWitnesses): void;

  /**
   * @returns {TransactionWitnessSet}
   */
  static new(): TransactionWitnessSet;
}
declare export class UnitInterval {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {UnitInterval}
   */
  static from_bytes(bytes: Uint8Array): UnitInterval;

  /**
   * @param {BigInt} index_0
   * @param {BigInt} index_1
   * @returns {UnitInterval}
   */
  static new(index_0: BigInt, index_1: BigInt): UnitInterval;
}
declare export class VRFKeyHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {VRFKeyHash}
   */
  static from_bytes(bytes: Uint8Array): VRFKeyHash;
}
declare export class Vkey {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Vkey}
   */
  static from_bytes(bytes: Uint8Array): Vkey;

  /**
   * @param {PublicKey} pk
   * @returns {Vkey}
   */
  static new(pk: PublicKey): Vkey;
}
declare export class Vkeywitness {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Vkeywitness}
   */
  static from_bytes(bytes: Uint8Array): Vkeywitness;

  /**
   * @param {Vkey} vkey
   * @param {Ed25519Signature} signature
   * @returns {Vkeywitness}
   */
  static new(vkey: Vkey, signature: Ed25519Signature): Vkeywitness;
}
declare export class Vkeywitnesses {
  free(): void;

  /**
   * @returns {Vkeywitnesses}
   */
  static new(): Vkeywitnesses;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {Vkeywitness}
   */
  get(index: number): Vkeywitness;

  /**
   * @param {Vkeywitness} elem
   */
  add(elem: Vkeywitness): void;
}
declare export class Withdrawals {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Withdrawals}
   */
  static from_bytes(bytes: Uint8Array): Withdrawals;

  /**
   * @returns {Withdrawals}
   */
  static new(): Withdrawals;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {RewardAddress} key
   * @param {BigInt} value
   * @returns {BigInt | void}
   */
  insert(key: RewardAddress, value: BigInt): BigInt | void;
}
