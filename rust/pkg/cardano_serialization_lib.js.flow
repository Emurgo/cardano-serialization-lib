/**
 * Flowtype definitions for cardano_serialization_lib
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.11.0
 * @flow
 */

/**
 * @param {TransactionHash} tx_body_hash
 * @param {ByronAddress} addr
 * @param {LegacyDaedalusPrivateKey} key
 * @returns {BootstrapWitness}
 */
declare export function make_daedalus_bootstrap_witness(
  tx_body_hash: TransactionHash,
  addr: ByronAddress,
  key: LegacyDaedalusPrivateKey
): BootstrapWitness;

/**
 * @param {TransactionHash} tx_body_hash
 * @param {ByronAddress} addr
 * @param {Bip32PrivateKey} key
 * @returns {BootstrapWitness}
 */
declare export function make_icarus_bootstrap_witness(
  tx_body_hash: TransactionHash,
  addr: ByronAddress,
  key: Bip32PrivateKey
): BootstrapWitness;

/**
 * @param {TransactionHash} tx_body_hash
 * @param {PrivateKey} sk
 * @returns {Vkeywitness}
 */
declare export function make_vkey_witness(
  tx_body_hash: TransactionHash,
  sk: PrivateKey
): Vkeywitness;

/**
 * @param {TransactionMetadata} metadata
 * @returns {MetadataHash}
 */
declare export function hash_metadata(
  metadata: TransactionMetadata
): MetadataHash;

/**
 * @param {TransactionBody} tx_body
 * @returns {TransactionHash}
 */
declare export function hash_transaction(
  tx_body: TransactionBody
): TransactionHash;

/**
 * @param {TransactionBody} txbody
 * @param {BigNum} pool_deposit
 * @param {BigNum} key_deposit
 * @returns {Value}
 */
declare export function get_implicit_input(
  txbody: TransactionBody,
  pool_deposit: BigNum,
  key_deposit: BigNum
): Value;

/**
 * @param {TransactionBody} txbody
 * @param {BigNum} pool_deposit
 * @param {BigNum} key_deposit
 * @returns {BigNum}
 */
declare export function get_deposit(
  txbody: TransactionBody,
  pool_deposit: BigNum,
  key_deposit: BigNum
): BigNum;

/**
 * @param {Value} assets
 * @param {BigNum} minimum_utxo_val
 * @returns {BigNum}
 */
declare export function min_ada_required(
  assets: Value,
  minimum_utxo_val: BigNum
): BigNum;

/**
 * @param {Uint8Array} bytes
 * @returns {TransactionMetadatum}
 */
declare export function encode_arbitrary_bytes_as_metadatum(
  bytes: Uint8Array
): TransactionMetadatum;

/**
 * @param {TransactionMetadatum} metadata
 * @returns {Uint8Array}
 */
declare export function decode_arbitrary_bytes_from_metadatum(
  metadata: TransactionMetadatum
): Uint8Array;

/**
 * @param {string} json
 * @param {number} schema
 * @returns {TransactionMetadatum}
 */
declare export function encode_json_str_to_metadatum(
  json: string,
  schema: number
): TransactionMetadatum;

/**
 * @param {TransactionMetadatum} metadatum
 * @param {number} schema
 * @returns {string}
 */
declare export function decode_metadatum_to_json_str(
  metadatum: TransactionMetadatum,
  schema: number
): string;

/**
 * @param {Transaction} tx
 * @param {LinearFee} linear_fee
 * @returns {BigNum}
 */
declare export function min_fee(tx: Transaction, linear_fee: LinearFee): BigNum;

/**
 * @param {string} password
 * @param {string} salt
 * @param {string} nonce
 * @param {string} data
 * @returns {string}
 */
declare export function encrypt_with_password(
  password: string,
  salt: string,
  nonce: string,
  data: string
): string;

/**
 * @param {string} password
 * @param {string} data
 * @returns {string}
 */
declare export function decrypt_with_password(
  password: string,
  data: string
): string;

/**
 */

declare export var CertificateKind: {|
  +StakeRegistration: 0, // 0
  +StakeDeregistration: 1, // 1
  +StakeDelegation: 2, // 2
  +PoolRegistration: 3, // 3
  +PoolRetirement: 4, // 4
  +GenesisKeyDelegation: 5, // 5
  +MoveInstantaneousRewardsCert: 6, // 6
|};

/**
 */

declare export var MIRPot: {|
  +Reserves: 0, // 0
  +Treasury: 1, // 1
|};

/**
 */

declare export var RelayKind: {|
  +SingleHostAddr: 0, // 0
  +SingleHostName: 1, // 1
  +MultiHostName: 2, // 2
|};

/**
 */

declare export var NativeScriptKind: {|
  +ScriptPubkey: 0, // 0
  +ScriptAll: 1, // 1
  +ScriptAny: 2, // 2
  +ScriptNOfK: 3, // 3
  +TimelockStart: 4, // 4
  +TimelockExpiry: 5, // 5
|};

/**
 * Each new language uses a different namespace for hashing its script
 * This is because you could have a language where the same bytes have different semantics
 * So this avoids scripts in different languages mapping to the same hash
 * Note that the enum value here is different than the enum value for deciding the cost model of a script
 */

declare export var ScriptHashNamespace: {|
  +NativeScript: 0, // 0
|};

/**
 */

declare export var TransactionMetadatumKind: {|
  +MetadataMap: 0, // 0
  +MetadataList: 1, // 1
  +Int: 2, // 2
  +Bytes: 3, // 3
  +Text: 4, // 4
|};

/**
 */

declare export var MetadataJsonSchema: {|
  +NoConversions: 0, // 0
  +BasicConversions: 1, // 1
  +DetailedSchema: 2, // 2
|};

/**
 */
declare export class Address {
  free(): void;

  /**
   * @param {Uint8Array} data
   * @returns {Address}
   */
  static from_bytes(data: Uint8Array): Address;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {string | void} prefix
   * @returns {string}
   */
  to_bech32(prefix?: string): string;

  /**
   * @param {string} bech_str
   * @returns {Address}
   */
  static from_bech32(bech_str: string): Address;

  /**
   * @returns {number}
   */
  network_id(): number;
}
/**
 */
declare export class AssetName {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {AssetName}
   */
  static from_bytes(bytes: Uint8Array): AssetName;

  /**
   * @param {Uint8Array} name
   * @returns {AssetName}
   */
  static new(name: Uint8Array): AssetName;

  /**
   * @returns {Uint8Array}
   */
  name(): Uint8Array;
}
/**
 */
declare export class AssetNames {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {AssetNames}
   */
  static from_bytes(bytes: Uint8Array): AssetNames;

  /**
   * @returns {AssetNames}
   */
  static new(): AssetNames;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {AssetName}
   */
  get(index: number): AssetName;

  /**
   * @param {AssetName} elem
   */
  add(elem: AssetName): void;
}
/**
 */
declare export class Assets {
  free(): void;

  /**
   * @returns {Assets}
   */
  static new(): Assets;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {AssetName} key
   * @param {BigNum} value
   * @returns {BigNum | void}
   */
  insert(key: AssetName, value: BigNum): BigNum | void;

  /**
   * @param {AssetName} key
   * @returns {BigNum | void}
   */
  get(key: AssetName): BigNum | void;

  /**
   * @returns {AssetNames}
   */
  keys(): AssetNames;
}
/**
 */
declare export class BaseAddress {
  free(): void;

  /**
   * @param {number} network
   * @param {StakeCredential} payment
   * @param {StakeCredential} stake
   * @returns {BaseAddress}
   */
  static new(
    network: number,
    payment: StakeCredential,
    stake: StakeCredential
  ): BaseAddress;

  /**
   * @returns {StakeCredential}
   */
  payment_cred(): StakeCredential;

  /**
   * @returns {StakeCredential}
   */
  stake_cred(): StakeCredential;

  /**
   * @returns {Address}
   */
  to_address(): Address;

  /**
   * @param {Address} addr
   * @returns {BaseAddress | void}
   */
  static from_address(addr: Address): BaseAddress | void;
}
/**
 */
declare export class BigNum {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {BigNum}
   */
  static from_bytes(bytes: Uint8Array): BigNum;

  /**
   * @param {string} string
   * @returns {BigNum}
   */
  static from_str(string: string): BigNum;

  /**
   * @returns {string}
   */
  to_str(): string;

  /**
   * @param {BigNum} other
   * @returns {BigNum}
   */
  checked_mul(other: BigNum): BigNum;

  /**
   * @param {BigNum} other
   * @returns {BigNum}
   */
  checked_add(other: BigNum): BigNum;

  /**
   * @param {BigNum} other
   * @returns {BigNum}
   */
  checked_sub(other: BigNum): BigNum;

  /**
   * returns 0 if it would otherwise underflow
   * @param {BigNum} other
   * @returns {BigNum}
   */
  clamped_sub(other: BigNum): BigNum;

  /**
   * @param {BigNum} rhs_value
   * @returns {number}
   */
  compare(rhs_value: BigNum): number;
}
/**
 */
declare export class Bip32PrivateKey {
  free(): void;

  /**
   * derive this private key with the given index.
   *
   * # Security considerations
   *
   * * hard derivation index cannot be soft derived with the public key
   *
   * # Hard derivation vs Soft derivation
   *
   * If you pass an index below 0x80000000 then it is a soft derivation.
   * The advantage of soft derivation is that it is possible to derive the
   * public key too. I.e. derivation the private key with a soft derivation
   * index and then retrieving the associated public key is equivalent to
   * deriving the public key associated to the parent private key.
   *
   * Hard derivation index does not allow public key derivation.
   *
   * This is why deriving the private key should not fail while deriving
   * the public key may fail (if the derivation index is invalid).
   * @param {number} index
   * @returns {Bip32PrivateKey}
   */
  derive(index: number): Bip32PrivateKey;

  /**
   * 128-byte xprv a key format in Cardano that some software still uses or requires
   * the traditional 96-byte xprv is simply encoded as
   * prv | chaincode
   * however, because some software may not know how to compute a public key from a private key,
   * the 128-byte inlines the public key in the following format
   * prv | pub | chaincode
   * so be careful if you see the term "xprv" as it could refer to either one
   * our library does not require the pub (instead we compute the pub key when needed)
   * @param {Uint8Array} bytes
   * @returns {Bip32PrivateKey}
   */
  static from_128_xprv(bytes: Uint8Array): Bip32PrivateKey;

  /**
   * see from_128_xprv
   * @returns {Uint8Array}
   */
  to_128_xprv(): Uint8Array;

  /**
   * @returns {Bip32PrivateKey}
   */
  static generate_ed25519_bip32(): Bip32PrivateKey;

  /**
   * @returns {PrivateKey}
   */
  to_raw_key(): PrivateKey;

  /**
   * @returns {Bip32PublicKey}
   */
  to_public(): Bip32PublicKey;

  /**
   * @param {Uint8Array} bytes
   * @returns {Bip32PrivateKey}
   */
  static from_bytes(bytes: Uint8Array): Bip32PrivateKey;

  /**
   * @returns {Uint8Array}
   */
  as_bytes(): Uint8Array;

  /**
   * @param {string} bech32_str
   * @returns {Bip32PrivateKey}
   */
  static from_bech32(bech32_str: string): Bip32PrivateKey;

  /**
   * @returns {string}
   */
  to_bech32(): string;

  /**
   * @param {Uint8Array} entropy
   * @param {Uint8Array} password
   * @returns {Bip32PrivateKey}
   */
  static from_bip39_entropy(
    entropy: Uint8Array,
    password: Uint8Array
  ): Bip32PrivateKey;

  /**
   * @returns {Uint8Array}
   */
  chaincode(): Uint8Array;
}
/**
 */
declare export class Bip32PublicKey {
  free(): void;

  /**
   * derive this public key with the given index.
   *
   * # Errors
   *
   * If the index is not a soft derivation index (< 0x80000000) then
   * calling this method will fail.
   *
   * # Security considerations
   *
   * * hard derivation index cannot be soft derived with the public key
   *
   * # Hard derivation vs Soft derivation
   *
   * If you pass an index below 0x80000000 then it is a soft derivation.
   * The advantage of soft derivation is that it is possible to derive the
   * public key too. I.e. derivation the private key with a soft derivation
   * index and then retrieving the associated public key is equivalent to
   * deriving the public key associated to the parent private key.
   *
   * Hard derivation index does not allow public key derivation.
   *
   * This is why deriving the private key should not fail while deriving
   * the public key may fail (if the derivation index is invalid).
   * @param {number} index
   * @returns {Bip32PublicKey}
   */
  derive(index: number): Bip32PublicKey;

  /**
   * @returns {PublicKey}
   */
  to_raw_key(): PublicKey;

  /**
   * @param {Uint8Array} bytes
   * @returns {Bip32PublicKey}
   */
  static from_bytes(bytes: Uint8Array): Bip32PublicKey;

  /**
   * @returns {Uint8Array}
   */
  as_bytes(): Uint8Array;

  /**
   * @param {string} bech32_str
   * @returns {Bip32PublicKey}
   */
  static from_bech32(bech32_str: string): Bip32PublicKey;

  /**
   * @returns {string}
   */
  to_bech32(): string;

  /**
   * @returns {Uint8Array}
   */
  chaincode(): Uint8Array;
}
/**
 */
declare export class Block {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Block}
   */
  static from_bytes(bytes: Uint8Array): Block;

  /**
   * @returns {Header}
   */
  header(): Header;

  /**
   * @returns {TransactionBodies}
   */
  transaction_bodies(): TransactionBodies;

  /**
   * @returns {TransactionWitnessSets}
   */
  transaction_witness_sets(): TransactionWitnessSets;

  /**
   * @returns {MapTransactionIndexToTransactionMetadata}
   */
  transaction_metadata_set(): MapTransactionIndexToTransactionMetadata;

  /**
   * @param {Header} header
   * @param {TransactionBodies} transaction_bodies
   * @param {TransactionWitnessSets} transaction_witness_sets
   * @param {MapTransactionIndexToTransactionMetadata} transaction_metadata_set
   * @returns {Block}
   */
  static new(
    header: Header,
    transaction_bodies: TransactionBodies,
    transaction_witness_sets: TransactionWitnessSets,
    transaction_metadata_set: MapTransactionIndexToTransactionMetadata
  ): Block;
}
/**
 */
declare export class BlockHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix: string): string;

  /**
   * @param {string} bech_str
   * @returns {BlockHash}
   */
  static from_bech32(bech_str: string): BlockHash;

  /**
   * @param {Uint8Array} bytes
   * @returns {BlockHash}
   */
  static from_bytes(bytes: Uint8Array): BlockHash;
}
/**
 */
declare export class BootstrapWitness {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {BootstrapWitness}
   */
  static from_bytes(bytes: Uint8Array): BootstrapWitness;

  /**
   * @returns {Vkey}
   */
  vkey(): Vkey;

  /**
   * @returns {Ed25519Signature}
   */
  signature(): Ed25519Signature;

  /**
   * @returns {Uint8Array}
   */
  chain_code(): Uint8Array;

  /**
   * @returns {Uint8Array}
   */
  attributes(): Uint8Array;

  /**
   * @param {Vkey} vkey
   * @param {Ed25519Signature} signature
   * @param {Uint8Array} chain_code
   * @param {Uint8Array} attributes
   * @returns {BootstrapWitness}
   */
  static new(
    vkey: Vkey,
    signature: Ed25519Signature,
    chain_code: Uint8Array,
    attributes: Uint8Array
  ): BootstrapWitness;
}
/**
 */
declare export class BootstrapWitnesses {
  free(): void;

  /**
   * @returns {BootstrapWitnesses}
   */
  static new(): BootstrapWitnesses;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {BootstrapWitness}
   */
  get(index: number): BootstrapWitness;

  /**
   * @param {BootstrapWitness} elem
   */
  add(elem: BootstrapWitness): void;
}
/**
 */
declare export class ByronAddress {
  free(): void;

  /**
   * @returns {string}
   */
  to_base58(): string;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {ByronAddress}
   */
  static from_bytes(bytes: Uint8Array): ByronAddress;

  /**
   * returns the byron protocol magic embedded in the address, or mainnet id if none is present
   * note: for bech32 addresses, you need to use network_id instead
   * @returns {number}
   */
  byron_protocol_magic(): number;

  /**
   * @returns {Uint8Array}
   */
  attributes(): Uint8Array;

  /**
   * @returns {number}
   */
  network_id(): number;

  /**
   * @param {string} s
   * @returns {ByronAddress}
   */
  static from_base58(s: string): ByronAddress;

  /**
   * @param {Bip32PublicKey} key
   * @param {number} protocol_magic
   * @returns {ByronAddress}
   */
  static icarus_from_key(
    key: Bip32PublicKey,
    protocol_magic: number
  ): ByronAddress;

  /**
   * @param {string} s
   * @returns {boolean}
   */
  static is_valid(s: string): boolean;

  /**
   * @returns {Address}
   */
  to_address(): Address;

  /**
   * @param {Address} addr
   * @returns {ByronAddress | void}
   */
  static from_address(addr: Address): ByronAddress | void;
}
/**
 */
declare export class Certificate {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Certificate}
   */
  static from_bytes(bytes: Uint8Array): Certificate;

  /**
   * @param {StakeRegistration} stake_registration
   * @returns {Certificate}
   */
  static new_stake_registration(
    stake_registration: StakeRegistration
  ): Certificate;

  /**
   * @param {StakeDeregistration} stake_deregistration
   * @returns {Certificate}
   */
  static new_stake_deregistration(
    stake_deregistration: StakeDeregistration
  ): Certificate;

  /**
   * @param {StakeDelegation} stake_delegation
   * @returns {Certificate}
   */
  static new_stake_delegation(stake_delegation: StakeDelegation): Certificate;

  /**
   * @param {PoolRegistration} pool_registration
   * @returns {Certificate}
   */
  static new_pool_registration(
    pool_registration: PoolRegistration
  ): Certificate;

  /**
   * @param {PoolRetirement} pool_retirement
   * @returns {Certificate}
   */
  static new_pool_retirement(pool_retirement: PoolRetirement): Certificate;

  /**
   * @param {GenesisKeyDelegation} genesis_key_delegation
   * @returns {Certificate}
   */
  static new_genesis_key_delegation(
    genesis_key_delegation: GenesisKeyDelegation
  ): Certificate;

  /**
   * @param {MoveInstantaneousRewardsCert} move_instantaneous_rewards_cert
   * @returns {Certificate}
   */
  static new_move_instantaneous_rewards_cert(
    move_instantaneous_rewards_cert: MoveInstantaneousRewardsCert
  ): Certificate;

  /**
   * @returns {number}
   */
  kind(): number;

  /**
   * @returns {StakeRegistration | void}
   */
  as_stake_registration(): StakeRegistration | void;

  /**
   * @returns {StakeDeregistration | void}
   */
  as_stake_deregistration(): StakeDeregistration | void;

  /**
   * @returns {StakeDelegation | void}
   */
  as_stake_delegation(): StakeDelegation | void;

  /**
   * @returns {PoolRegistration | void}
   */
  as_pool_registration(): PoolRegistration | void;

  /**
   * @returns {PoolRetirement | void}
   */
  as_pool_retirement(): PoolRetirement | void;

  /**
   * @returns {GenesisKeyDelegation | void}
   */
  as_genesis_key_delegation(): GenesisKeyDelegation | void;

  /**
   * @returns {MoveInstantaneousRewardsCert | void}
   */
  as_move_instantaneous_rewards_cert(): MoveInstantaneousRewardsCert | void;
}
/**
 */
declare export class Certificates {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Certificates}
   */
  static from_bytes(bytes: Uint8Array): Certificates;

  /**
   * @returns {Certificates}
   */
  static new(): Certificates;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {Certificate}
   */
  get(index: number): Certificate;

  /**
   * @param {Certificate} elem
   */
  add(elem: Certificate): void;
}
/**
 */
declare export class DNSRecordAorAAAA {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {DNSRecordAorAAAA}
   */
  static from_bytes(bytes: Uint8Array): DNSRecordAorAAAA;

  /**
   * @param {string} dns_name
   * @returns {DNSRecordAorAAAA}
   */
  static new(dns_name: string): DNSRecordAorAAAA;

  /**
   * @returns {string}
   */
  record(): string;
}
/**
 */
declare export class DNSRecordSRV {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {DNSRecordSRV}
   */
  static from_bytes(bytes: Uint8Array): DNSRecordSRV;

  /**
   * @param {string} dns_name
   * @returns {DNSRecordSRV}
   */
  static new(dns_name: string): DNSRecordSRV;

  /**
   * @returns {string}
   */
  record(): string;
}
/**
 */
declare export class Ed25519KeyHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix: string): string;

  /**
   * @param {string} bech_str
   * @returns {Ed25519KeyHash}
   */
  static from_bech32(bech_str: string): Ed25519KeyHash;

  /**
   * @param {Uint8Array} bytes
   * @returns {Ed25519KeyHash}
   */
  static from_bytes(bytes: Uint8Array): Ed25519KeyHash;
}
/**
 */
declare export class Ed25519KeyHashes {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Ed25519KeyHashes}
   */
  static from_bytes(bytes: Uint8Array): Ed25519KeyHashes;

  /**
   * @returns {Ed25519KeyHashes}
   */
  static new(): Ed25519KeyHashes;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {Ed25519KeyHash}
   */
  get(index: number): Ed25519KeyHash;

  /**
   * @param {Ed25519KeyHash} elem
   */
  add(elem: Ed25519KeyHash): void;
}
/**
 */
declare export class Ed25519Signature {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @returns {string}
   */
  to_bech32(): string;

  /**
   * @returns {string}
   */
  to_hex(): string;

  /**
   * @param {string} bech32_str
   * @returns {Ed25519Signature}
   */
  static from_bech32(bech32_str: string): Ed25519Signature;

  /**
   * @param {string} input
   * @returns {Ed25519Signature}
   */
  static from_hex(input: string): Ed25519Signature;

  /**
   * @param {Uint8Array} bytes
   * @returns {Ed25519Signature}
   */
  static from_bytes(bytes: Uint8Array): Ed25519Signature;
}
/**
 */
declare export class EnterpriseAddress {
  free(): void;

  /**
   * @param {number} network
   * @param {StakeCredential} payment
   * @returns {EnterpriseAddress}
   */
  static new(network: number, payment: StakeCredential): EnterpriseAddress;

  /**
   * @returns {StakeCredential}
   */
  payment_cred(): StakeCredential;

  /**
   * @returns {Address}
   */
  to_address(): Address;

  /**
   * @param {Address} addr
   * @returns {EnterpriseAddress | void}
   */
  static from_address(addr: Address): EnterpriseAddress | void;
}
/**
 */
declare export class GeneralTransactionMetadata {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {GeneralTransactionMetadata}
   */
  static from_bytes(bytes: Uint8Array): GeneralTransactionMetadata;

  /**
   * @returns {GeneralTransactionMetadata}
   */
  static new(): GeneralTransactionMetadata;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {BigNum} key
   * @param {TransactionMetadatum} value
   * @returns {TransactionMetadatum | void}
   */
  insert(key: BigNum, value: TransactionMetadatum): TransactionMetadatum | void;

  /**
   * @param {BigNum} key
   * @returns {TransactionMetadatum | void}
   */
  get(key: BigNum): TransactionMetadatum | void;

  /**
   * @returns {TransactionMetadatumLabels}
   */
  keys(): TransactionMetadatumLabels;
}
/**
 */
declare export class GenesisDelegateHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix: string): string;

  /**
   * @param {string} bech_str
   * @returns {GenesisDelegateHash}
   */
  static from_bech32(bech_str: string): GenesisDelegateHash;

  /**
   * @param {Uint8Array} bytes
   * @returns {GenesisDelegateHash}
   */
  static from_bytes(bytes: Uint8Array): GenesisDelegateHash;
}
/**
 */
declare export class GenesisHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix: string): string;

  /**
   * @param {string} bech_str
   * @returns {GenesisHash}
   */
  static from_bech32(bech_str: string): GenesisHash;

  /**
   * @param {Uint8Array} bytes
   * @returns {GenesisHash}
   */
  static from_bytes(bytes: Uint8Array): GenesisHash;
}
/**
 */
declare export class GenesisHashes {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {GenesisHashes}
   */
  static from_bytes(bytes: Uint8Array): GenesisHashes;

  /**
   * @returns {GenesisHashes}
   */
  static new(): GenesisHashes;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {GenesisHash}
   */
  get(index: number): GenesisHash;

  /**
   * @param {GenesisHash} elem
   */
  add(elem: GenesisHash): void;
}
/**
 */
declare export class GenesisKeyDelegation {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {GenesisKeyDelegation}
   */
  static from_bytes(bytes: Uint8Array): GenesisKeyDelegation;

  /**
   * @returns {GenesisHash}
   */
  genesishash(): GenesisHash;

  /**
   * @returns {GenesisDelegateHash}
   */
  genesis_delegate_hash(): GenesisDelegateHash;

  /**
   * @returns {VRFKeyHash}
   */
  vrf_keyhash(): VRFKeyHash;

  /**
   * @param {GenesisHash} genesishash
   * @param {GenesisDelegateHash} genesis_delegate_hash
   * @param {VRFKeyHash} vrf_keyhash
   * @returns {GenesisKeyDelegation}
   */
  static new(
    genesishash: GenesisHash,
    genesis_delegate_hash: GenesisDelegateHash,
    vrf_keyhash: VRFKeyHash
  ): GenesisKeyDelegation;
}
/**
 */
declare export class Header {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Header}
   */
  static from_bytes(bytes: Uint8Array): Header;

  /**
   * @returns {HeaderBody}
   */
  header_body(): HeaderBody;

  /**
   * @returns {KESSignature}
   */
  body_signature(): KESSignature;

  /**
   * @param {HeaderBody} header_body
   * @param {KESSignature} body_signature
   * @returns {Header}
   */
  static new(header_body: HeaderBody, body_signature: KESSignature): Header;
}
/**
 */
declare export class HeaderBody {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {HeaderBody}
   */
  static from_bytes(bytes: Uint8Array): HeaderBody;

  /**
   * @returns {number}
   */
  block_number(): number;

  /**
   * @returns {number}
   */
  slot(): number;

  /**
   * @returns {BlockHash | void}
   */
  prev_hash(): BlockHash | void;

  /**
   * @returns {Vkey}
   */
  issuer_vkey(): Vkey;

  /**
   * @returns {VRFVKey}
   */
  vrf_vkey(): VRFVKey;

  /**
   * @returns {VRFCert}
   */
  nonce_vrf(): VRFCert;

  /**
   * @returns {VRFCert}
   */
  leader_vrf(): VRFCert;

  /**
   * @returns {number}
   */
  block_body_size(): number;

  /**
   * @returns {BlockHash}
   */
  block_body_hash(): BlockHash;

  /**
   * @returns {OperationalCert}
   */
  operational_cert(): OperationalCert;

  /**
   * @returns {ProtocolVersion}
   */
  protocol_version(): ProtocolVersion;

  /**
   * @param {number} block_number
   * @param {number} slot
   * @param {BlockHash | void} prev_hash
   * @param {Vkey} issuer_vkey
   * @param {VRFVKey} vrf_vkey
   * @param {VRFCert} nonce_vrf
   * @param {VRFCert} leader_vrf
   * @param {number} block_body_size
   * @param {BlockHash} block_body_hash
   * @param {OperationalCert} operational_cert
   * @param {ProtocolVersion} protocol_version
   * @returns {HeaderBody}
   */
  static new(
    block_number: number,
    slot: number,
    prev_hash: BlockHash | void,
    issuer_vkey: Vkey,
    vrf_vkey: VRFVKey,
    nonce_vrf: VRFCert,
    leader_vrf: VRFCert,
    block_body_size: number,
    block_body_hash: BlockHash,
    operational_cert: OperationalCert,
    protocol_version: ProtocolVersion
  ): HeaderBody;
}
/**
 */
declare export class Int {
  free(): void;

  /**
   * @param {BigNum} x
   * @returns {Int}
   */
  static new(x: BigNum): Int;

  /**
   * @param {BigNum} x
   * @returns {Int}
   */
  static new_negative(x: BigNum): Int;

  /**
   * @param {number} x
   * @returns {Int}
   */
  static new_i32(x: number): Int;

  /**
   * @returns {boolean}
   */
  is_positive(): boolean;

  /**
   * @returns {BigNum | void}
   */
  as_positive(): BigNum | void;

  /**
   * @returns {BigNum | void}
   */
  as_negative(): BigNum | void;

  /**
   * @returns {number | void}
   */
  as_i32(): number | void;
}
/**
 */
declare export class Ipv4 {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Ipv4}
   */
  static from_bytes(bytes: Uint8Array): Ipv4;

  /**
   * @param {Uint8Array} data
   * @returns {Ipv4}
   */
  static new(data: Uint8Array): Ipv4;

  /**
   * @returns {Uint8Array}
   */
  ip(): Uint8Array;
}
/**
 */
declare export class Ipv6 {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Ipv6}
   */
  static from_bytes(bytes: Uint8Array): Ipv6;

  /**
   * @param {Uint8Array} data
   * @returns {Ipv6}
   */
  static new(data: Uint8Array): Ipv6;

  /**
   * @returns {Uint8Array}
   */
  ip(): Uint8Array;
}
/**
 */
declare export class KESSignature {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {KESSignature}
   */
  static from_bytes(bytes: Uint8Array): KESSignature;
}
/**
 */
declare export class KESVKey {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix: string): string;

  /**
   * @param {string} bech_str
   * @returns {KESVKey}
   */
  static from_bech32(bech_str: string): KESVKey;

  /**
   * @param {Uint8Array} bytes
   * @returns {KESVKey}
   */
  static from_bytes(bytes: Uint8Array): KESVKey;
}
/**
 */
declare export class LegacyDaedalusPrivateKey {
  free(): void;

  /**
   * @param {Uint8Array} bytes
   * @returns {LegacyDaedalusPrivateKey}
   */
  static from_bytes(bytes: Uint8Array): LegacyDaedalusPrivateKey;

  /**
   * @returns {Uint8Array}
   */
  as_bytes(): Uint8Array;

  /**
   * @returns {Uint8Array}
   */
  chaincode(): Uint8Array;
}
/**
 */
declare export class LinearFee {
  free(): void;

  /**
   * @returns {BigNum}
   */
  constant(): BigNum;

  /**
   * @returns {BigNum}
   */
  coefficient(): BigNum;

  /**
   * @param {BigNum} coefficient
   * @param {BigNum} constant
   * @returns {LinearFee}
   */
  static new(coefficient: BigNum, constant: BigNum): LinearFee;
}
/**
 */
declare export class MapTransactionIndexToTransactionMetadata {
  free(): void;

  /**
   * @returns {MapTransactionIndexToTransactionMetadata}
   */
  static new(): MapTransactionIndexToTransactionMetadata;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} key
   * @param {TransactionMetadata} value
   * @returns {TransactionMetadata | void}
   */
  insert(key: number, value: TransactionMetadata): TransactionMetadata | void;

  /**
   * @param {number} key
   * @returns {TransactionMetadata | void}
   */
  get(key: number): TransactionMetadata | void;

  /**
   * @returns {Uint32Array}
   */
  keys(): Uint32Array;
}
/**
 */
declare export class MetadataHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix: string): string;

  /**
   * @param {string} bech_str
   * @returns {MetadataHash}
   */
  static from_bech32(bech_str: string): MetadataHash;

  /**
   * @param {Uint8Array} bytes
   * @returns {MetadataHash}
   */
  static from_bytes(bytes: Uint8Array): MetadataHash;
}
/**
 */
declare export class MetadataList {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MetadataList}
   */
  static from_bytes(bytes: Uint8Array): MetadataList;

  /**
   * @returns {MetadataList}
   */
  static new(): MetadataList;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {TransactionMetadatum}
   */
  get(index: number): TransactionMetadatum;

  /**
   * @param {TransactionMetadatum} elem
   */
  add(elem: TransactionMetadatum): void;
}
/**
 */
declare export class MetadataMap {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MetadataMap}
   */
  static from_bytes(bytes: Uint8Array): MetadataMap;

  /**
   * @returns {MetadataMap}
   */
  static new(): MetadataMap;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {TransactionMetadatum} key
   * @param {TransactionMetadatum} value
   * @returns {TransactionMetadatum | void}
   */
  insert(
    key: TransactionMetadatum,
    value: TransactionMetadatum
  ): TransactionMetadatum | void;

  /**
   * @param {string} key
   * @param {TransactionMetadatum} value
   * @returns {TransactionMetadatum | void}
   */
  insert_str(
    key: string,
    value: TransactionMetadatum
  ): TransactionMetadatum | void;

  /**
   * @param {number} key
   * @param {TransactionMetadatum} value
   * @returns {TransactionMetadatum | void}
   */
  insert_i32(
    key: number,
    value: TransactionMetadatum
  ): TransactionMetadatum | void;

  /**
   * @param {TransactionMetadatum} key
   * @returns {TransactionMetadatum}
   */
  get(key: TransactionMetadatum): TransactionMetadatum;

  /**
   * @param {string} key
   * @returns {TransactionMetadatum}
   */
  get_str(key: string): TransactionMetadatum;

  /**
   * @param {number} key
   * @returns {TransactionMetadatum}
   */
  get_i32(key: number): TransactionMetadatum;

  /**
   * @param {TransactionMetadatum} key
   * @returns {boolean}
   */
  has(key: TransactionMetadatum): boolean;

  /**
   * @returns {MetadataList}
   */
  keys(): MetadataList;
}
/**
 */
declare export class Mint {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Mint}
   */
  static from_bytes(bytes: Uint8Array): Mint;

  /**
   * @returns {Mint}
   */
  static new(): Mint;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {ScriptHash} key
   * @param {MintAssets} value
   * @returns {MintAssets | void}
   */
  insert(key: ScriptHash, value: MintAssets): MintAssets | void;

  /**
   * @param {ScriptHash} key
   * @returns {MintAssets | void}
   */
  get(key: ScriptHash): MintAssets | void;

  /**
   * @returns {ScriptHashes}
   */
  keys(): ScriptHashes;
}
/**
 */
declare export class MintAssets {
  free(): void;

  /**
   * @returns {MintAssets}
   */
  static new(): MintAssets;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {AssetName} key
   * @param {Int} value
   * @returns {Int | void}
   */
  insert(key: AssetName, value: Int): Int | void;

  /**
   * @param {AssetName} key
   * @returns {Int | void}
   */
  get(key: AssetName): Int | void;

  /**
   * @returns {AssetNames}
   */
  keys(): AssetNames;
}
/**
 */
declare export class MoveInstantaneousReward {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MoveInstantaneousReward}
   */
  static from_bytes(bytes: Uint8Array): MoveInstantaneousReward;

  /**
   * @param {number} pot
   * @returns {MoveInstantaneousReward}
   */
  static new(pot: number): MoveInstantaneousReward;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {StakeCredential} key
   * @param {BigNum} value
   * @returns {BigNum | void}
   */
  insert(key: StakeCredential, value: BigNum): BigNum | void;

  /**
   * @param {StakeCredential} key
   * @returns {BigNum | void}
   */
  get(key: StakeCredential): BigNum | void;

  /**
   * @returns {StakeCredentials}
   */
  keys(): StakeCredentials;
}
/**
 */
declare export class MoveInstantaneousRewardsCert {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MoveInstantaneousRewardsCert}
   */
  static from_bytes(bytes: Uint8Array): MoveInstantaneousRewardsCert;

  /**
   * @returns {MoveInstantaneousReward}
   */
  move_instantaneous_reward(): MoveInstantaneousReward;

  /**
   * @param {MoveInstantaneousReward} move_instantaneous_reward
   * @returns {MoveInstantaneousRewardsCert}
   */
  static new(
    move_instantaneous_reward: MoveInstantaneousReward
  ): MoveInstantaneousRewardsCert;
}
/**
 */
declare export class MultiAsset {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MultiAsset}
   */
  static from_bytes(bytes: Uint8Array): MultiAsset;

  /**
   * @returns {MultiAsset}
   */
  static new(): MultiAsset;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {ScriptHash} key
   * @param {Assets} value
   * @returns {Assets | void}
   */
  insert(key: ScriptHash, value: Assets): Assets | void;

  /**
   * @param {ScriptHash} key
   * @returns {Assets | void}
   */
  get(key: ScriptHash): Assets | void;

  /**
   * @returns {ScriptHashes}
   */
  keys(): ScriptHashes;

  /**
   * removes an asset from the list if the result is 0 or less
   * @param {MultiAsset} rhs_ma
   * @returns {MultiAsset}
   */
  sub(rhs_ma: MultiAsset): MultiAsset;
}
/**
 */
declare export class MultiHostName {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {MultiHostName}
   */
  static from_bytes(bytes: Uint8Array): MultiHostName;

  /**
   * @returns {DNSRecordSRV}
   */
  dns_name(): DNSRecordSRV;

  /**
   * @param {DNSRecordSRV} dns_name
   * @returns {MultiHostName}
   */
  static new(dns_name: DNSRecordSRV): MultiHostName;
}
/**
 */
declare export class NativeScript {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {NativeScript}
   */
  static from_bytes(bytes: Uint8Array): NativeScript;

  /**
   * @param {number} namespace
   * @returns {Ed25519KeyHash}
   */
  hash(namespace: number): Ed25519KeyHash;

  /**
   * @param {ScriptPubkey} script_pubkey
   * @returns {NativeScript}
   */
  static new_script_pubkey(script_pubkey: ScriptPubkey): NativeScript;

  /**
   * @param {ScriptAll} script_all
   * @returns {NativeScript}
   */
  static new_script_all(script_all: ScriptAll): NativeScript;

  /**
   * @param {ScriptAny} script_any
   * @returns {NativeScript}
   */
  static new_script_any(script_any: ScriptAny): NativeScript;

  /**
   * @param {ScriptNOfK} script_n_of_k
   * @returns {NativeScript}
   */
  static new_script_n_of_k(script_n_of_k: ScriptNOfK): NativeScript;

  /**
   * @param {TimelockStart} timelock_start
   * @returns {NativeScript}
   */
  static new_timelock_start(timelock_start: TimelockStart): NativeScript;

  /**
   * @param {TimelockExpiry} timelock_expiry
   * @returns {NativeScript}
   */
  static new_timelock_expiry(timelock_expiry: TimelockExpiry): NativeScript;

  /**
   * @returns {number}
   */
  kind(): number;

  /**
   * @returns {ScriptPubkey | void}
   */
  as_script_pubkey(): ScriptPubkey | void;

  /**
   * @returns {ScriptAll | void}
   */
  as_script_all(): ScriptAll | void;

  /**
   * @returns {ScriptAny | void}
   */
  as_script_any(): ScriptAny | void;

  /**
   * @returns {ScriptNOfK | void}
   */
  as_script_n_of_k(): ScriptNOfK | void;

  /**
   * @returns {TimelockStart | void}
   */
  as_timelock_start(): TimelockStart | void;

  /**
   * @returns {TimelockExpiry | void}
   */
  as_timelock_expiry(): TimelockExpiry | void;
}
/**
 */
declare export class NativeScripts {
  free(): void;

  /**
   * @returns {NativeScripts}
   */
  static new(): NativeScripts;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {NativeScript}
   */
  get(index: number): NativeScript;

  /**
   * @param {NativeScript} elem
   */
  add(elem: NativeScript): void;
}
/**
 */
declare export class NetworkInfo {
  free(): void;

  /**
   * @param {number} network_id
   * @param {number} protocol_magic
   * @returns {NetworkInfo}
   */
  static new(network_id: number, protocol_magic: number): NetworkInfo;

  /**
   * @returns {number}
   */
  network_id(): number;

  /**
   * @returns {number}
   */
  protocol_magic(): number;

  /**
   * @returns {NetworkInfo}
   */
  static testnet(): NetworkInfo;

  /**
   * @returns {NetworkInfo}
   */
  static mainnet(): NetworkInfo;
}
/**
 */
declare export class Nonce {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Nonce}
   */
  static from_bytes(bytes: Uint8Array): Nonce;

  /**
   * @returns {Nonce}
   */
  static new_identity(): Nonce;

  /**
   * @param {Uint8Array} hash
   * @returns {Nonce}
   */
  static new_from_hash(hash: Uint8Array): Nonce;

  /**
   * @returns {Uint8Array | void}
   */
  get_hash(): Uint8Array | void;
}
/**
 */
declare export class OperationalCert {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {OperationalCert}
   */
  static from_bytes(bytes: Uint8Array): OperationalCert;

  /**
   * @returns {KESVKey}
   */
  hot_vkey(): KESVKey;

  /**
   * @returns {number}
   */
  sequence_number(): number;

  /**
   * @returns {number}
   */
  kes_period(): number;

  /**
   * @returns {Ed25519Signature}
   */
  sigma(): Ed25519Signature;

  /**
   * @param {KESVKey} hot_vkey
   * @param {number} sequence_number
   * @param {number} kes_period
   * @param {Ed25519Signature} sigma
   * @returns {OperationalCert}
   */
  static new(
    hot_vkey: KESVKey,
    sequence_number: number,
    kes_period: number,
    sigma: Ed25519Signature
  ): OperationalCert;
}
/**
 */
declare export class Pointer {
  free(): void;

  /**
   * @param {number} slot
   * @param {number} tx_index
   * @param {number} cert_index
   * @returns {Pointer}
   */
  static new(slot: number, tx_index: number, cert_index: number): Pointer;

  /**
   * @returns {number}
   */
  slot(): number;

  /**
   * @returns {number}
   */
  tx_index(): number;

  /**
   * @returns {number}
   */
  cert_index(): number;
}
/**
 */
declare export class PointerAddress {
  free(): void;

  /**
   * @param {number} network
   * @param {StakeCredential} payment
   * @param {Pointer} stake
   * @returns {PointerAddress}
   */
  static new(
    network: number,
    payment: StakeCredential,
    stake: Pointer
  ): PointerAddress;

  /**
   * @returns {StakeCredential}
   */
  payment_cred(): StakeCredential;

  /**
   * @returns {Pointer}
   */
  stake_pointer(): Pointer;

  /**
   * @returns {Address}
   */
  to_address(): Address;

  /**
   * @param {Address} addr
   * @returns {PointerAddress | void}
   */
  static from_address(addr: Address): PointerAddress | void;
}
/**
 */
declare export class PoolMetadata {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {PoolMetadata}
   */
  static from_bytes(bytes: Uint8Array): PoolMetadata;

  /**
   * @returns {URL}
   */
  url(): URL;

  /**
   * @returns {MetadataHash}
   */
  metadata_hash(): MetadataHash;

  /**
   * @param {URL} url
   * @param {MetadataHash} metadata_hash
   * @returns {PoolMetadata}
   */
  static new(url: URL, metadata_hash: MetadataHash): PoolMetadata;
}
/**
 */
declare export class PoolParams {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {PoolParams}
   */
  static from_bytes(bytes: Uint8Array): PoolParams;

  /**
   * @returns {Ed25519KeyHash}
   */
  operator(): Ed25519KeyHash;

  /**
   * @returns {VRFKeyHash}
   */
  vrf_keyhash(): VRFKeyHash;

  /**
   * @returns {BigNum}
   */
  pledge(): BigNum;

  /**
   * @returns {BigNum}
   */
  cost(): BigNum;

  /**
   * @returns {UnitInterval}
   */
  margin(): UnitInterval;

  /**
   * @returns {RewardAddress}
   */
  reward_account(): RewardAddress;

  /**
   * @returns {Ed25519KeyHashes}
   */
  pool_owners(): Ed25519KeyHashes;

  /**
   * @returns {Relays}
   */
  relays(): Relays;

  /**
   * @returns {PoolMetadata | void}
   */
  pool_metadata(): PoolMetadata | void;

  /**
   * @param {Ed25519KeyHash} operator
   * @param {VRFKeyHash} vrf_keyhash
   * @param {BigNum} pledge
   * @param {BigNum} cost
   * @param {UnitInterval} margin
   * @param {RewardAddress} reward_account
   * @param {Ed25519KeyHashes} pool_owners
   * @param {Relays} relays
   * @param {PoolMetadata | void} pool_metadata
   * @returns {PoolParams}
   */
  static new(
    operator: Ed25519KeyHash,
    vrf_keyhash: VRFKeyHash,
    pledge: BigNum,
    cost: BigNum,
    margin: UnitInterval,
    reward_account: RewardAddress,
    pool_owners: Ed25519KeyHashes,
    relays: Relays,
    pool_metadata?: PoolMetadata
  ): PoolParams;
}
/**
 */
declare export class PoolRegistration {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {PoolRegistration}
   */
  static from_bytes(bytes: Uint8Array): PoolRegistration;

  /**
   * @returns {PoolParams}
   */
  pool_params(): PoolParams;

  /**
   * @param {PoolParams} pool_params
   * @returns {PoolRegistration}
   */
  static new(pool_params: PoolParams): PoolRegistration;
}
/**
 */
declare export class PoolRetirement {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {PoolRetirement}
   */
  static from_bytes(bytes: Uint8Array): PoolRetirement;

  /**
   * @returns {Ed25519KeyHash}
   */
  pool_keyhash(): Ed25519KeyHash;

  /**
   * @returns {number}
   */
  epoch(): number;

  /**
   * @param {Ed25519KeyHash} pool_keyhash
   * @param {number} epoch
   * @returns {PoolRetirement}
   */
  static new(pool_keyhash: Ed25519KeyHash, epoch: number): PoolRetirement;
}
/**
 */
declare export class PrivateKey {
  free(): void;

  /**
   * @returns {PublicKey}
   */
  to_public(): PublicKey;

  /**
   * @returns {PrivateKey}
   */
  static generate_ed25519(): PrivateKey;

  /**
   * @returns {PrivateKey}
   */
  static generate_ed25519extended(): PrivateKey;

  /**
   * @returns {string}
   */
  to_bech32(): string;

  /**
   * @returns {Uint8Array}
   */
  as_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {PrivateKey}
   */
  static from_extended_bytes(bytes: Uint8Array): PrivateKey;

  /**
   * @param {Uint8Array} bytes
   * @returns {PrivateKey}
   */
  static from_normal_bytes(bytes: Uint8Array): PrivateKey;

  /**
   * @param {Uint8Array} message
   * @returns {Ed25519Signature}
   */
  sign(message: Uint8Array): Ed25519Signature;
}
/**
 */
declare export class ProposedProtocolParameterUpdates {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {ProposedProtocolParameterUpdates}
   */
  static from_bytes(bytes: Uint8Array): ProposedProtocolParameterUpdates;

  /**
   * @returns {ProposedProtocolParameterUpdates}
   */
  static new(): ProposedProtocolParameterUpdates;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {GenesisHash} key
   * @param {ProtocolParamUpdate} value
   * @returns {ProtocolParamUpdate | void}
   */
  insert(
    key: GenesisHash,
    value: ProtocolParamUpdate
  ): ProtocolParamUpdate | void;

  /**
   * @param {GenesisHash} key
   * @returns {ProtocolParamUpdate | void}
   */
  get(key: GenesisHash): ProtocolParamUpdate | void;

  /**
   * @returns {GenesisHashes}
   */
  keys(): GenesisHashes;
}
/**
 */
declare export class ProtocolParamUpdate {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {ProtocolParamUpdate}
   */
  static from_bytes(bytes: Uint8Array): ProtocolParamUpdate;

  /**
   * @param {BigNum} minfee_a
   */
  set_minfee_a(minfee_a: BigNum): void;

  /**
   * @returns {BigNum | void}
   */
  minfee_a(): BigNum | void;

  /**
   * @param {BigNum} minfee_b
   */
  set_minfee_b(minfee_b: BigNum): void;

  /**
   * @returns {BigNum | void}
   */
  minfee_b(): BigNum | void;

  /**
   * @param {number} max_block_body_size
   */
  set_max_block_body_size(max_block_body_size: number): void;

  /**
   * @returns {number | void}
   */
  max_block_body_size(): number | void;

  /**
   * @param {number} max_tx_size
   */
  set_max_tx_size(max_tx_size: number): void;

  /**
   * @returns {number | void}
   */
  max_tx_size(): number | void;

  /**
   * @param {number} max_block_header_size
   */
  set_max_block_header_size(max_block_header_size: number): void;

  /**
   * @returns {number | void}
   */
  max_block_header_size(): number | void;

  /**
   * @param {BigNum} key_deposit
   */
  set_key_deposit(key_deposit: BigNum): void;

  /**
   * @returns {BigNum | void}
   */
  key_deposit(): BigNum | void;

  /**
   * @param {BigNum} pool_deposit
   */
  set_pool_deposit(pool_deposit: BigNum): void;

  /**
   * @returns {BigNum | void}
   */
  pool_deposit(): BigNum | void;

  /**
   * @param {number} max_epoch
   */
  set_max_epoch(max_epoch: number): void;

  /**
   * @returns {number | void}
   */
  max_epoch(): number | void;

  /**
   * @param {number} n_opt
   */
  set_n_opt(n_opt: number): void;

  /**
   * @returns {number | void}
   */
  n_opt(): number | void;

  /**
   * @param {UnitInterval} pool_pledge_influence
   */
  set_pool_pledge_influence(pool_pledge_influence: UnitInterval): void;

  /**
   * @returns {UnitInterval | void}
   */
  pool_pledge_influence(): UnitInterval | void;

  /**
   * @param {UnitInterval} expansion_rate
   */
  set_expansion_rate(expansion_rate: UnitInterval): void;

  /**
   * @returns {UnitInterval | void}
   */
  expansion_rate(): UnitInterval | void;

  /**
   * @param {UnitInterval} treasury_growth_rate
   */
  set_treasury_growth_rate(treasury_growth_rate: UnitInterval): void;

  /**
   * @returns {UnitInterval | void}
   */
  treasury_growth_rate(): UnitInterval | void;

  /**
   * @param {UnitInterval} d
   */
  set_d(d: UnitInterval): void;

  /**
   * @returns {UnitInterval | void}
   */
  d(): UnitInterval | void;

  /**
   * @param {Nonce} extra_entropy
   */
  set_extra_entropy(extra_entropy: Nonce): void;

  /**
   * @returns {Nonce | void}
   */
  extra_entropy(): Nonce | void;

  /**
   * @param {ProtocolVersions} protocol_version
   */
  set_protocol_version(protocol_version: ProtocolVersions): void;

  /**
   * @returns {ProtocolVersions | void}
   */
  protocol_version(): ProtocolVersions | void;

  /**
   * @param {BigNum} min_utxo_value
   */
  set_min_utxo_value(min_utxo_value: BigNum): void;

  /**
   * @returns {BigNum | void}
   */
  min_utxo_value(): BigNum | void;

  /**
   * @returns {ProtocolParamUpdate}
   */
  static new(): ProtocolParamUpdate;
}
/**
 */
declare export class ProtocolVersion {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {ProtocolVersion}
   */
  static from_bytes(bytes: Uint8Array): ProtocolVersion;

  /**
   * @returns {number}
   */
  major(): number;

  /**
   * @returns {number}
   */
  minor(): number;

  /**
   * @param {number} major
   * @param {number} minor
   * @returns {ProtocolVersion}
   */
  static new(major: number, minor: number): ProtocolVersion;
}
/**
 */
declare export class ProtocolVersions {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {ProtocolVersions}
   */
  static from_bytes(bytes: Uint8Array): ProtocolVersions;

  /**
   * @returns {ProtocolVersions}
   */
  static new(): ProtocolVersions;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {ProtocolVersion}
   */
  get(index: number): ProtocolVersion;

  /**
   * @param {ProtocolVersion} elem
   */
  add(elem: ProtocolVersion): void;
}
/**
 * ED25519 key used as public key
 */
declare export class PublicKey {
  free(): void;

  /**
   * Get public key from its bech32 representation
   * Example:
   * ```javascript
   * const pkey = PublicKey.from_bech32(&#39;ed25519_pk1dgaagyh470y66p899txcl3r0jaeaxu6yd7z2dxyk55qcycdml8gszkxze2&#39;);
   * ```
   * @param {string} bech32_str
   * @returns {PublicKey}
   */
  static from_bech32(bech32_str: string): PublicKey;

  /**
   * @returns {string}
   */
  to_bech32(): string;

  /**
   * @returns {Uint8Array}
   */
  as_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {PublicKey}
   */
  static from_bytes(bytes: Uint8Array): PublicKey;

  /**
   * @param {Uint8Array} data
   * @param {Ed25519Signature} signature
   * @returns {boolean}
   */
  verify(data: Uint8Array, signature: Ed25519Signature): boolean;

  /**
   * @returns {Ed25519KeyHash}
   */
  hash(): Ed25519KeyHash;
}
/**
 */
declare export class PublicKeys {
  free(): void;

  /**
   */
  constructor(): this;

  /**
   * @returns {number}
   */
  size(): number;

  /**
   * @param {number} index
   * @returns {PublicKey}
   */
  get(index: number): PublicKey;

  /**
   * @param {PublicKey} key
   */
  add(key: PublicKey): void;
}
/**
 */
declare export class Relay {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Relay}
   */
  static from_bytes(bytes: Uint8Array): Relay;

  /**
   * @param {SingleHostAddr} single_host_addr
   * @returns {Relay}
   */
  static new_single_host_addr(single_host_addr: SingleHostAddr): Relay;

  /**
   * @param {SingleHostName} single_host_name
   * @returns {Relay}
   */
  static new_single_host_name(single_host_name: SingleHostName): Relay;

  /**
   * @param {MultiHostName} multi_host_name
   * @returns {Relay}
   */
  static new_multi_host_name(multi_host_name: MultiHostName): Relay;

  /**
   * @returns {number}
   */
  kind(): number;

  /**
   * @returns {SingleHostAddr | void}
   */
  as_single_host_addr(): SingleHostAddr | void;

  /**
   * @returns {SingleHostName | void}
   */
  as_single_host_name(): SingleHostName | void;

  /**
   * @returns {MultiHostName | void}
   */
  as_multi_host_name(): MultiHostName | void;
}
/**
 */
declare export class Relays {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Relays}
   */
  static from_bytes(bytes: Uint8Array): Relays;

  /**
   * @returns {Relays}
   */
  static new(): Relays;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {Relay}
   */
  get(index: number): Relay;

  /**
   * @param {Relay} elem
   */
  add(elem: Relay): void;
}
/**
 */
declare export class RewardAddress {
  free(): void;

  /**
   * @param {number} network
   * @param {StakeCredential} payment
   * @returns {RewardAddress}
   */
  static new(network: number, payment: StakeCredential): RewardAddress;

  /**
   * @returns {StakeCredential}
   */
  payment_cred(): StakeCredential;

  /**
   * @returns {Address}
   */
  to_address(): Address;

  /**
   * @param {Address} addr
   * @returns {RewardAddress | void}
   */
  static from_address(addr: Address): RewardAddress | void;
}
/**
 */
declare export class RewardAddresses {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {RewardAddresses}
   */
  static from_bytes(bytes: Uint8Array): RewardAddresses;

  /**
   * @returns {RewardAddresses}
   */
  static new(): RewardAddresses;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {RewardAddress}
   */
  get(index: number): RewardAddress;

  /**
   * @param {RewardAddress} elem
   */
  add(elem: RewardAddress): void;
}
/**
 */
declare export class ScriptAll {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptAll}
   */
  static from_bytes(bytes: Uint8Array): ScriptAll;

  /**
   * @returns {NativeScripts}
   */
  native_scripts(): NativeScripts;

  /**
   * @param {NativeScripts} native_scripts
   * @returns {ScriptAll}
   */
  static new(native_scripts: NativeScripts): ScriptAll;
}
/**
 */
declare export class ScriptAny {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptAny}
   */
  static from_bytes(bytes: Uint8Array): ScriptAny;

  /**
   * @returns {NativeScripts}
   */
  native_scripts(): NativeScripts;

  /**
   * @param {NativeScripts} native_scripts
   * @returns {ScriptAny}
   */
  static new(native_scripts: NativeScripts): ScriptAny;
}
/**
 */
declare export class ScriptHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix: string): string;

  /**
   * @param {string} bech_str
   * @returns {ScriptHash}
   */
  static from_bech32(bech_str: string): ScriptHash;

  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptHash}
   */
  static from_bytes(bytes: Uint8Array): ScriptHash;
}
/**
 */
declare export class ScriptHashes {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptHashes}
   */
  static from_bytes(bytes: Uint8Array): ScriptHashes;

  /**
   * @returns {ScriptHashes}
   */
  static new(): ScriptHashes;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {ScriptHash}
   */
  get(index: number): ScriptHash;

  /**
   * @param {ScriptHash} elem
   */
  add(elem: ScriptHash): void;
}
/**
 */
declare export class ScriptNOfK {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptNOfK}
   */
  static from_bytes(bytes: Uint8Array): ScriptNOfK;

  /**
   * @returns {number}
   */
  n(): number;

  /**
   * @returns {NativeScripts}
   */
  native_scripts(): NativeScripts;

  /**
   * @param {number} n
   * @param {NativeScripts} native_scripts
   * @returns {ScriptNOfK}
   */
  static new(n: number, native_scripts: NativeScripts): ScriptNOfK;
}
/**
 */
declare export class ScriptPubkey {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptPubkey}
   */
  static from_bytes(bytes: Uint8Array): ScriptPubkey;

  /**
   * @returns {Ed25519KeyHash}
   */
  addr_keyhash(): Ed25519KeyHash;

  /**
   * @param {Ed25519KeyHash} addr_keyhash
   * @returns {ScriptPubkey}
   */
  static new(addr_keyhash: Ed25519KeyHash): ScriptPubkey;
}
/**
 */
declare export class SingleHostAddr {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {SingleHostAddr}
   */
  static from_bytes(bytes: Uint8Array): SingleHostAddr;

  /**
   * @returns {number | void}
   */
  port(): number | void;

  /**
   * @returns {Ipv4 | void}
   */
  ipv4(): Ipv4 | void;

  /**
   * @returns {Ipv6 | void}
   */
  ipv6(): Ipv6 | void;

  /**
   * @param {number | void} port
   * @param {Ipv4 | void} ipv4
   * @param {Ipv6 | void} ipv6
   * @returns {SingleHostAddr}
   */
  static new(port?: number, ipv4?: Ipv4, ipv6?: Ipv6): SingleHostAddr;
}
/**
 */
declare export class SingleHostName {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {SingleHostName}
   */
  static from_bytes(bytes: Uint8Array): SingleHostName;

  /**
   * @returns {number | void}
   */
  port(): number | void;

  /**
   * @returns {DNSRecordAorAAAA}
   */
  dns_name(): DNSRecordAorAAAA;

  /**
   * @param {number | void} port
   * @param {DNSRecordAorAAAA} dns_name
   * @returns {SingleHostName}
   */
  static new(port: number | void, dns_name: DNSRecordAorAAAA): SingleHostName;
}
/**
 */
declare export class StakeCredential {
  free(): void;

  /**
   * @param {Ed25519KeyHash} hash
   * @returns {StakeCredential}
   */
  static from_keyhash(hash: Ed25519KeyHash): StakeCredential;

  /**
   * @param {ScriptHash} hash
   * @returns {StakeCredential}
   */
  static from_scripthash(hash: ScriptHash): StakeCredential;

  /**
   * @returns {Ed25519KeyHash | void}
   */
  to_keyhash(): Ed25519KeyHash | void;

  /**
   * @returns {ScriptHash | void}
   */
  to_scripthash(): ScriptHash | void;

  /**
   * @returns {number}
   */
  kind(): number;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {StakeCredential}
   */
  static from_bytes(bytes: Uint8Array): StakeCredential;
}
/**
 */
declare export class StakeCredentials {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {StakeCredentials}
   */
  static from_bytes(bytes: Uint8Array): StakeCredentials;

  /**
   * @returns {StakeCredentials}
   */
  static new(): StakeCredentials;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {StakeCredential}
   */
  get(index: number): StakeCredential;

  /**
   * @param {StakeCredential} elem
   */
  add(elem: StakeCredential): void;
}
/**
 */
declare export class StakeDelegation {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {StakeDelegation}
   */
  static from_bytes(bytes: Uint8Array): StakeDelegation;

  /**
   * @returns {StakeCredential}
   */
  stake_credential(): StakeCredential;

  /**
   * @returns {Ed25519KeyHash}
   */
  pool_keyhash(): Ed25519KeyHash;

  /**
   * @param {StakeCredential} stake_credential
   * @param {Ed25519KeyHash} pool_keyhash
   * @returns {StakeDelegation}
   */
  static new(
    stake_credential: StakeCredential,
    pool_keyhash: Ed25519KeyHash
  ): StakeDelegation;
}
/**
 */
declare export class StakeDeregistration {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {StakeDeregistration}
   */
  static from_bytes(bytes: Uint8Array): StakeDeregistration;

  /**
   * @returns {StakeCredential}
   */
  stake_credential(): StakeCredential;

  /**
   * @param {StakeCredential} stake_credential
   * @returns {StakeDeregistration}
   */
  static new(stake_credential: StakeCredential): StakeDeregistration;
}
/**
 */
declare export class StakeRegistration {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {StakeRegistration}
   */
  static from_bytes(bytes: Uint8Array): StakeRegistration;

  /**
   * @returns {StakeCredential}
   */
  stake_credential(): StakeCredential;

  /**
   * @param {StakeCredential} stake_credential
   * @returns {StakeRegistration}
   */
  static new(stake_credential: StakeCredential): StakeRegistration;
}
/**
 */
declare export class TimelockExpiry {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TimelockExpiry}
   */
  static from_bytes(bytes: Uint8Array): TimelockExpiry;

  /**
   * @returns {number}
   */
  slot(): number;

  /**
   * @param {number} slot
   * @returns {TimelockExpiry}
   */
  static new(slot: number): TimelockExpiry;
}
/**
 */
declare export class TimelockStart {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TimelockStart}
   */
  static from_bytes(bytes: Uint8Array): TimelockStart;

  /**
   * @returns {number}
   */
  slot(): number;

  /**
   * @param {number} slot
   * @returns {TimelockStart}
   */
  static new(slot: number): TimelockStart;
}
/**
 */
declare export class Transaction {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Transaction}
   */
  static from_bytes(bytes: Uint8Array): Transaction;

  /**
   * @returns {TransactionBody}
   */
  body(): TransactionBody;

  /**
   * @returns {TransactionWitnessSet}
   */
  witness_set(): TransactionWitnessSet;

  /**
   * @returns {TransactionMetadata | void}
   */
  metadata(): TransactionMetadata | void;

  /**
   * @param {TransactionBody} body
   * @param {TransactionWitnessSet} witness_set
   * @param {TransactionMetadata | void} metadata
   * @returns {Transaction}
   */
  static new(
    body: TransactionBody,
    witness_set: TransactionWitnessSet,
    metadata?: TransactionMetadata
  ): Transaction;
}
/**
 */
declare export class TransactionBodies {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionBodies}
   */
  static from_bytes(bytes: Uint8Array): TransactionBodies;

  /**
   * @returns {TransactionBodies}
   */
  static new(): TransactionBodies;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {TransactionBody}
   */
  get(index: number): TransactionBody;

  /**
   * @param {TransactionBody} elem
   */
  add(elem: TransactionBody): void;
}
/**
 */
declare export class TransactionBody {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionBody}
   */
  static from_bytes(bytes: Uint8Array): TransactionBody;

  /**
   * @returns {TransactionInputs}
   */
  inputs(): TransactionInputs;

  /**
   * @returns {TransactionOutputs}
   */
  outputs(): TransactionOutputs;

  /**
   * @returns {BigNum}
   */
  fee(): BigNum;

  /**
   * @returns {number | void}
   */
  ttl(): number | void;

  /**
   * @param {Certificates} certs
   */
  set_certs(certs: Certificates): void;

  /**
   * @returns {Certificates | void}
   */
  certs(): Certificates | void;

  /**
   * @param {Withdrawals} withdrawals
   */
  set_withdrawals(withdrawals: Withdrawals): void;

  /**
   * @returns {Withdrawals | void}
   */
  withdrawals(): Withdrawals | void;

  /**
   * @param {Update} update
   */
  set_update(update: Update): void;

  /**
   * @returns {Update | void}
   */
  update(): Update | void;

  /**
   * @param {MetadataHash} metadata_hash
   */
  set_metadata_hash(metadata_hash: MetadataHash): void;

  /**
   * @returns {MetadataHash | void}
   */
  metadata_hash(): MetadataHash | void;

  /**
   * @param {number} validity_start_interval
   */
  set_validity_start_interval(validity_start_interval: number): void;

  /**
   * @returns {number | void}
   */
  validity_start_interval(): number | void;

  /**
   * @param {Mint} mint
   */
  set_mint(mint: Mint): void;

  /**
   * @returns {Mint | void}
   */
  multiassets(): Mint | void;

  /**
   * @param {TransactionInputs} inputs
   * @param {TransactionOutputs} outputs
   * @param {BigNum} fee
   * @param {number | void} ttl
   * @returns {TransactionBody}
   */
  static new(
    inputs: TransactionInputs,
    outputs: TransactionOutputs,
    fee: BigNum,
    ttl?: number
  ): TransactionBody;
}
/**
 */
declare export class TransactionBuilder {
  free(): void;

  /**
   * @param {Ed25519KeyHash} hash
   * @param {TransactionInput} input
   * @param {Value} amount
   */
  add_key_input(
    hash: Ed25519KeyHash,
    input: TransactionInput,
    amount: Value
  ): void;

  /**
   * @param {ScriptHash} hash
   * @param {TransactionInput} input
   * @param {Value} amount
   */
  add_script_input(
    hash: ScriptHash,
    input: TransactionInput,
    amount: Value
  ): void;

  /**
   * @param {ByronAddress} hash
   * @param {TransactionInput} input
   * @param {Value} amount
   */
  add_bootstrap_input(
    hash: ByronAddress,
    input: TransactionInput,
    amount: Value
  ): void;

  /**
   * @param {Address} address
   * @param {TransactionInput} input
   * @param {Value} amount
   */
  add_input(address: Address, input: TransactionInput, amount: Value): void;

  /**
   * calculates how much the fee would increase if you added a given output
   * @param {Address} address
   * @param {TransactionInput} input
   * @param {Value} amount
   * @returns {BigNum}
   */
  fee_for_input(
    address: Address,
    input: TransactionInput,
    amount: Value
  ): BigNum;

  /**
   * @param {TransactionOutput} output
   */
  add_output(output: TransactionOutput): void;

  /**
   * calculates how much the fee would increase if you added a given output
   * @param {TransactionOutput} output
   * @returns {BigNum}
   */
  fee_for_output(output: TransactionOutput): BigNum;

  /**
   * @param {BigNum} fee
   */
  set_fee(fee: BigNum): void;

  /**
   * @param {number} ttl
   */
  set_ttl(ttl: number): void;

  /**
   * @param {number} validity_start_interval
   */
  set_validity_start_interval(validity_start_interval: number): void;

  /**
   * @param {Certificates} certs
   */
  set_certs(certs: Certificates): void;

  /**
   * @param {Withdrawals} withdrawals
   */
  set_withdrawals(withdrawals: Withdrawals): void;

  /**
   * @param {TransactionMetadata} metadata
   */
  set_metadata(metadata: TransactionMetadata): void;

  /**
   * @param {LinearFee} linear_fee
   * @param {BigNum} minimum_utxo_val
   * @param {BigNum} pool_deposit
   * @param {BigNum} key_deposit
   * @returns {TransactionBuilder}
   */
  static new(
    linear_fee: LinearFee,
    minimum_utxo_val: BigNum,
    pool_deposit: BigNum,
    key_deposit: BigNum
  ): TransactionBuilder;

  /**
   * does not include refunds or withdrawals
   * @returns {Value}
   */
  get_explicit_input(): Value;

  /**
   * withdrawals and refunds
   * @returns {Value}
   */
  get_implicit_input(): Value;

  /**
   * does not include fee
   * @returns {Value}
   */
  get_explicit_output(): Value;

  /**
   * @returns {BigNum}
   */
  get_deposit(): BigNum;

  /**
   * @returns {BigNum | void}
   */
  get_fee_if_set(): BigNum | void;

  /**
   * Warning: this function will mutate the /fee/ field
   * @param {Address} address
   * @returns {boolean}
   */
  add_change_if_needed(address: Address): boolean;

  /**
   * @returns {TransactionBody}
   */
  build(): TransactionBody;

  /**
   * warning: sum of all parts of a transaction must equal 0. You cannot just set the fee to the min value and forget about it
   * warning: min_fee may be slightly larger than the actual minimum fee (ex: a few lovelaces)
   * this is done to simplify the library code, but can be fixed later
   * @returns {BigNum}
   */
  min_fee(): BigNum;
}
/**
 */
declare export class TransactionHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix: string): string;

  /**
   * @param {string} bech_str
   * @returns {TransactionHash}
   */
  static from_bech32(bech_str: string): TransactionHash;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionHash}
   */
  static from_bytes(bytes: Uint8Array): TransactionHash;
}
/**
 */
declare export class TransactionInput {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionInput}
   */
  static from_bytes(bytes: Uint8Array): TransactionInput;

  /**
   * @returns {TransactionHash}
   */
  transaction_id(): TransactionHash;

  /**
   * @returns {number}
   */
  index(): number;

  /**
   * @param {TransactionHash} transaction_id
   * @param {number} index
   * @returns {TransactionInput}
   */
  static new(transaction_id: TransactionHash, index: number): TransactionInput;
}
/**
 */
declare export class TransactionInputs {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionInputs}
   */
  static from_bytes(bytes: Uint8Array): TransactionInputs;

  /**
   * @returns {TransactionInputs}
   */
  static new(): TransactionInputs;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {TransactionInput}
   */
  get(index: number): TransactionInput;

  /**
   * @param {TransactionInput} elem
   */
  add(elem: TransactionInput): void;
}
/**
 */
declare export class TransactionMetadata {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionMetadata}
   */
  static from_bytes(bytes: Uint8Array): TransactionMetadata;

  /**
   * @returns {GeneralTransactionMetadata}
   */
  general(): GeneralTransactionMetadata;

  /**
   * @returns {NativeScripts | void}
   */
  native_scripts(): NativeScripts | void;

  /**
   * @param {NativeScripts} native_scripts
   */
  set_native_scripts(native_scripts: NativeScripts): void;

  /**
   * @param {GeneralTransactionMetadata} general
   * @returns {TransactionMetadata}
   */
  static new(general: GeneralTransactionMetadata): TransactionMetadata;
}
/**
 */
declare export class TransactionMetadatum {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionMetadatum}
   */
  static from_bytes(bytes: Uint8Array): TransactionMetadatum;

  /**
   * @param {MetadataMap} map
   * @returns {TransactionMetadatum}
   */
  static new_map(map: MetadataMap): TransactionMetadatum;

  /**
   * @param {MetadataList} list
   * @returns {TransactionMetadatum}
   */
  static new_list(list: MetadataList): TransactionMetadatum;

  /**
   * @param {Int} int
   * @returns {TransactionMetadatum}
   */
  static new_int(int: Int): TransactionMetadatum;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionMetadatum}
   */
  static new_bytes(bytes: Uint8Array): TransactionMetadatum;

  /**
   * @param {string} text
   * @returns {TransactionMetadatum}
   */
  static new_text(text: string): TransactionMetadatum;

  /**
   * @returns {number}
   */
  kind(): number;

  /**
   * @returns {MetadataMap}
   */
  as_map(): MetadataMap;

  /**
   * @returns {MetadataList}
   */
  as_list(): MetadataList;

  /**
   * @returns {Int}
   */
  as_int(): Int;

  /**
   * @returns {Uint8Array}
   */
  as_bytes(): Uint8Array;

  /**
   * @returns {string}
   */
  as_text(): string;
}
/**
 */
declare export class TransactionMetadatumLabels {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionMetadatumLabels}
   */
  static from_bytes(bytes: Uint8Array): TransactionMetadatumLabels;

  /**
   * @returns {TransactionMetadatumLabels}
   */
  static new(): TransactionMetadatumLabels;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {BigNum}
   */
  get(index: number): BigNum;

  /**
   * @param {BigNum} elem
   */
  add(elem: BigNum): void;
}
/**
 */
declare export class TransactionOutput {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionOutput}
   */
  static from_bytes(bytes: Uint8Array): TransactionOutput;

  /**
   * @returns {Address}
   */
  address(): Address;

  /**
   * @returns {Value}
   */
  amount(): Value;

  /**
   * @param {Address} address
   * @param {Value} amount
   * @returns {TransactionOutput}
   */
  static new(address: Address, amount: Value): TransactionOutput;
}
/**
 */
declare export class TransactionOutputs {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionOutputs}
   */
  static from_bytes(bytes: Uint8Array): TransactionOutputs;

  /**
   * @returns {TransactionOutputs}
   */
  static new(): TransactionOutputs;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {TransactionOutput}
   */
  get(index: number): TransactionOutput;

  /**
   * @param {TransactionOutput} elem
   */
  add(elem: TransactionOutput): void;
}
/**
 */
declare export class TransactionWitnessSet {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionWitnessSet}
   */
  static from_bytes(bytes: Uint8Array): TransactionWitnessSet;

  /**
   * @param {Vkeywitnesses} vkeys
   */
  set_vkeys(vkeys: Vkeywitnesses): void;

  /**
   * @returns {Vkeywitnesses | void}
   */
  vkeys(): Vkeywitnesses | void;

  /**
   * @param {NativeScripts} scripts
   */
  set_scripts(scripts: NativeScripts): void;

  /**
   * @returns {NativeScripts | void}
   */
  scripts(): NativeScripts | void;

  /**
   * @param {BootstrapWitnesses} bootstraps
   */
  set_bootstraps(bootstraps: BootstrapWitnesses): void;

  /**
   * @returns {BootstrapWitnesses | void}
   */
  bootstraps(): BootstrapWitnesses | void;

  /**
   * @returns {TransactionWitnessSet}
   */
  static new(): TransactionWitnessSet;
}
/**
 */
declare export class TransactionWitnessSets {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionWitnessSets}
   */
  static from_bytes(bytes: Uint8Array): TransactionWitnessSets;

  /**
   * @returns {TransactionWitnessSets}
   */
  static new(): TransactionWitnessSets;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {TransactionWitnessSet}
   */
  get(index: number): TransactionWitnessSet;

  /**
   * @param {TransactionWitnessSet} elem
   */
  add(elem: TransactionWitnessSet): void;
}
/**
 */
declare export class URL {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {URL}
   */
  static from_bytes(bytes: Uint8Array): URL;

  /**
   * @param {string} url
   * @returns {URL}
   */
  static new(url: string): URL;

  /**
   * @returns {string}
   */
  url(): string;
}
/**
 */
declare export class UnitInterval {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {UnitInterval}
   */
  static from_bytes(bytes: Uint8Array): UnitInterval;

  /**
   * @returns {BigNum}
   */
  numerator(): BigNum;

  /**
   * @returns {BigNum}
   */
  denominator(): BigNum;

  /**
   * @param {BigNum} numerator
   * @param {BigNum} denominator
   * @returns {UnitInterval}
   */
  static new(numerator: BigNum, denominator: BigNum): UnitInterval;
}
/**
 */
declare export class Update {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Update}
   */
  static from_bytes(bytes: Uint8Array): Update;

  /**
   * @returns {ProposedProtocolParameterUpdates}
   */
  proposed_protocol_parameter_updates(): ProposedProtocolParameterUpdates;

  /**
   * @returns {number}
   */
  epoch(): number;

  /**
   * @param {ProposedProtocolParameterUpdates} proposed_protocol_parameter_updates
   * @param {number} epoch
   * @returns {Update}
   */
  static new(
    proposed_protocol_parameter_updates: ProposedProtocolParameterUpdates,
    epoch: number
  ): Update;
}
/**
 */
declare export class VRFCert {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {VRFCert}
   */
  static from_bytes(bytes: Uint8Array): VRFCert;

  /**
   * @returns {Uint8Array}
   */
  output(): Uint8Array;

  /**
   * @returns {Uint8Array}
   */
  proof(): Uint8Array;

  /**
   * @param {Uint8Array} output
   * @param {Uint8Array} proof
   * @returns {VRFCert}
   */
  static new(output: Uint8Array, proof: Uint8Array): VRFCert;
}
/**
 */
declare export class VRFKeyHash {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix: string): string;

  /**
   * @param {string} bech_str
   * @returns {VRFKeyHash}
   */
  static from_bech32(bech_str: string): VRFKeyHash;

  /**
   * @param {Uint8Array} bytes
   * @returns {VRFKeyHash}
   */
  static from_bytes(bytes: Uint8Array): VRFKeyHash;
}
/**
 */
declare export class VRFVKey {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix: string): string;

  /**
   * @param {string} bech_str
   * @returns {VRFVKey}
   */
  static from_bech32(bech_str: string): VRFVKey;

  /**
   * @param {Uint8Array} bytes
   * @returns {VRFVKey}
   */
  static from_bytes(bytes: Uint8Array): VRFVKey;
}
/**
 */
declare export class Value {
  free(): void;

  /**
   * @param {BigNum} coin
   * @returns {Value}
   */
  static new(coin: BigNum): Value;

  /**
   * @returns {BigNum}
   */
  coin(): BigNum;

  /**
   * @param {BigNum} coin
   */
  set_coin(coin: BigNum): void;

  /**
   * @returns {MultiAsset | void}
   */
  multiasset(): MultiAsset | void;

  /**
   * @param {MultiAsset} multiasset
   */
  set_multiasset(multiasset: MultiAsset): void;

  /**
   * @param {Value} rhs
   * @returns {Value}
   */
  checked_add(rhs: Value): Value;

  /**
   * @param {Value} rhs_value
   * @returns {Value}
   */
  checked_sub(rhs_value: Value): Value;

  /**
   * @param {Value} rhs_value
   * @returns {Value}
   */
  clamped_sub(rhs_value: Value): Value;

  /**
   * note: values are only partially comparable
   * @param {Value} rhs_value
   * @returns {number | void}
   */
  compare(rhs_value: Value): number | void;
}
/**
 */
declare export class Vkey {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Vkey}
   */
  static from_bytes(bytes: Uint8Array): Vkey;

  /**
   * @param {PublicKey} pk
   * @returns {Vkey}
   */
  static new(pk: PublicKey): Vkey;

  /**
   * @returns {PublicKey}
   */
  public_key(): PublicKey;
}
/**
 */
declare export class Vkeywitness {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Vkeywitness}
   */
  static from_bytes(bytes: Uint8Array): Vkeywitness;

  /**
   * @param {Vkey} vkey
   * @param {Ed25519Signature} signature
   * @returns {Vkeywitness}
   */
  static new(vkey: Vkey, signature: Ed25519Signature): Vkeywitness;

  /**
   * @returns {Vkey}
   */
  vkey(): Vkey;

  /**
   * @returns {Ed25519Signature}
   */
  signature(): Ed25519Signature;
}
/**
 */
declare export class Vkeywitnesses {
  free(): void;

  /**
   * @returns {Vkeywitnesses}
   */
  static new(): Vkeywitnesses;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {number} index
   * @returns {Vkeywitness}
   */
  get(index: number): Vkeywitness;

  /**
   * @param {Vkeywitness} elem
   */
  add(elem: Vkeywitness): void;
}
/**
 */
declare export class Withdrawals {
  free(): void;

  /**
   * @returns {Uint8Array}
   */
  to_bytes(): Uint8Array;

  /**
   * @param {Uint8Array} bytes
   * @returns {Withdrawals}
   */
  static from_bytes(bytes: Uint8Array): Withdrawals;

  /**
   * @returns {Withdrawals}
   */
  static new(): Withdrawals;

  /**
   * @returns {number}
   */
  len(): number;

  /**
   * @param {RewardAddress} key
   * @param {BigNum} value
   * @returns {BigNum | void}
   */
  insert(key: RewardAddress, value: BigNum): BigNum | void;

  /**
   * @param {RewardAddress} key
   * @returns {BigNum | void}
   */
  get(key: RewardAddress): BigNum | void;

  /**
   * @returns {RewardAddresses}
   */
  keys(): RewardAddresses;
}
